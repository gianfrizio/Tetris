<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=3.0, user-scalable=yes">
    <title>🎮 Tetris Classic - Gioca Online Gratis</title>
    <meta name="description" content="Gioca al classico Tetris online gratis! Tetris moderno in WebAssembly con grafica SDL2, audio e controlli perfetti.">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <meta property="og:title" content="🎮 Tetris Classic - Gioca Online Gratis">
    <meta property="og:description" content="Il leggendario puzzle game Tetris ora disponibile gratis nel browser!">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a40 50%, #2d1b69 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Particelle animate di sfondo */
        .bg-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #64ffda;
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
            opacity: 0.6;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }

        /* Header */
        .header {
            text-align: center;
            padding: 2rem 1rem;
            position: relative;
            z-index: 10;
        }

        .title {
            font-family: 'Orbitron', monospace;
            font-size: clamp(2.5rem, 8vw, 5rem);
            font-weight: 900;
            background: linear-gradient(45deg, #64ffda, #00bcd4, #2196f3, #9c27b0);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(100, 255, 218, 0.5);
            margin-bottom: 0.5rem;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            font-size: 1.2rem;
            color: #b0bec5;
            margin-bottom: 1rem;
            font-weight: 300;
        }

        .game-info {
            font-size: 0.9rem;
            color: #78909c;
            max-width: 600px;
            margin: 0 auto 2rem;
            line-height: 1.6;
        }

        /* Container del gioco */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 1rem;
            position: relative;
            z-index: 5;
        }

        .game-wrapper {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            margin-bottom: 2rem;
        }

        .game-wrapper::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #64ffda, #2196f3, #9c27b0, #64ffda);
            border-radius: 22px;
            z-index: -1;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        /* Layout del gioco con pannelli laterali */
        .game-layout {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 2rem;
            min-height: 500px;
        }

        .left-stats, .right-info {
            flex: 0 0 200px;
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Spazio tra i pannelli nella colonna */
        }

        .game-canvas {
            flex: 0 0 auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        /* Pannelli statistiche */
        .stats-panel, .info-panel {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            padding: 1.5rem;
            border: 2px solid rgba(100, 255, 218, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        /* Solo il pannello stats a sinistra sarà sticky */
        .left-stats .stats-panel {
            position: sticky;
            top: 2rem;
        }
        
        /* Debug: assicurati che i pannelli non si sovrappongano */
        .right-info .info-panel:nth-child(1) {
            order: 1;
        }
        
        .right-info .info-panel:nth-child(2) {
            order: 2;
        }
        
        /* Controllo specifico per pannelli nella colonna destra */
        .right-info {
            display: flex !important;
            flex-direction: column !important;
            gap: 1rem !important;
            align-items: stretch !important;
        }
        
        .right-info .info-panel {
            position: static !important; /* Forza posizionamento statico per evitare sovrapposizioni */
            margin: 0 !important; /* Rimuovi tutti i margin */
            z-index: auto !important;
            transform: none !important;
        }
        
        .right-info .info-panel.audio-controls {
            position: static !important;
            margin-top: 0 !important;
        }
        
        /* Rimuovi sticky su mobile per evitare conflitti */
        @media (max-width: 768px) {
            .stats-panel, .info-panel {
                position: static;
            }
        }

        .stats-title, .info-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: #64ffda;
            text-align: center;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
        }

        .stat-item, .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 1.2rem;
            padding: 0.8rem;
            background: rgba(100, 255, 218, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            transition: all 0.3s ease;
        }

        .stat-item:hover, .info-item:hover {
            background: rgba(100, 255, 218, 0.2);
            border-color: rgba(100, 255, 218, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(100, 255, 218, 0.2);
        }

        .stat-label, .info-label {
            font-size: 0.9rem;
            color: #b0bec5;
            margin-bottom: 0.5rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value, .info-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.4rem;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 0 8px rgba(100, 255, 218, 0.6);
            background: linear-gradient(45deg, #64ffda, #00bcd4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Canvas styling */
        #canvas {
            border-radius: 12px;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            background: #000;
            display: block;
            margin: 0 auto;

            /* Default canvas sizing: let JS set internal buffer but allow CSS scaling */
            width: auto;      /* preserve default on desktop */
            height: auto;
            max-width: 100%;  /* never overflow its container */
            touch-action: none; /* prevent double interactions on mobile */
        }

        /* Responsive canvas wrapper to control visual scaling */
        .game-canvas {
            flex: 0 0 auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
        }

        /* Controlli */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin: 1.5rem 0;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(100, 255, 218, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 0.7rem;
            padding: 0.8rem 1.2rem;
            background: rgba(100, 255, 218, 0.15);
            border-radius: 10px;
            border: 2px solid rgba(100, 255, 218, 0.4);
            transition: all 0.3s ease;
            min-width: 120px;
            justify-content: center;
        }

        .control-item:hover {
            background: rgba(100, 255, 218, 0.25);
            border-color: rgba(100, 255, 218, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(100, 255, 218, 0.2);
        }

        .control-key {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #ffffff;
            background: linear-gradient(135deg, #64ffda, #2196f3);
            padding: 0.3rem 0.7rem;
            border-radius: 6px;
            font-size: 0.9rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 2px 8px rgba(100, 255, 218, 0.3);
            min-width: 35px;
            text-align: center;
        }

        .control-desc {
            color: #ffffff;
            font-size: 1rem;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
        }

        /* Loading personalizzato */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 35, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .tetris-loader {
            display: flex;
            gap: 4px;
            margin-bottom: 2rem;
        }

        .tetris-block {
            width: 20px;
            height: 20px;
            border-radius: 2px;
            animation: tetrisFall 1.5s ease-in-out infinite;
        }

        .tetris-block:nth-child(1) { background: #64ffda; animation-delay: 0s; }
        .tetris-block:nth-child(2) { background: #2196f3; animation-delay: 0.2s; }
        .tetris-block:nth-child(3) { background: #9c27b0; animation-delay: 0.4s; }
        .tetris-block:nth-child(4) { background: #ff5722; animation-delay: 0.6s; }

        @keyframes tetrisFall {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(20px); }
        }

        .loading-text {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: #64ffda;
            margin-bottom: 1rem;
        }

        .loading-progress {
            color: #78909c;
            font-size: 1rem;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 2rem 1rem;
            color: #546e7a;
            font-size: 0.9rem;
        }

        .footer a {
            color: #64ffda;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .footer a:hover {
            color: #00bcd4;
        }

        /* Mobile Optimization */
        @media (max-width: 768px) {
            .game-wrapper {
                padding: 1rem;
                margin: 0 0.5rem 1rem;
            }

            /* Remove minimum height forcing overflow on small screens */
            .game-layout {
                min-height: auto;
            }

            /* Scale canvas so it always fits into the viewport
               - max-width limits visual width
               - max-height prevents it from exceeding available vertical space */
            .game-canvas {
                width: 100%;
                max-width: 90vw;
            }

            #canvas {
                /* Let the canvas scale to fit the screen while keeping aspect ratio */
                width: 100% !important;
                height: auto !important;
                max-width: 520px; /* reasonable upper bound for tablets */
                max-height: calc(100vh - 220px); /* reserve space for header/controls/footer */
            }

            .game-layout {
                flex-direction: column;
                gap: 1rem;
                align-items: center;
            }

            .left-stats, .right-info {
                flex: none;
                width: 100%;
                max-width: 400px;
            }

            .stats-panel, .info-panel {
                position: static;
                padding: 1rem;
            }

            .stat-item, .info-item {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.8rem;
            }

            .stat-label, .info-label {
                margin-bottom: 0;
                text-align: left;
            }

            .stat-value, .info-value {
                font-size: 1.2rem;
                text-align: right;
            }
            
            .controls {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 0.8rem;
                padding: 1rem;
            }
            
            .control-item {
                justify-content: center;
                padding: 1rem;
                min-width: auto;
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }
            
            .control-key {
                font-size: 1.1rem;
                padding: 0.5rem 0.8rem;
                min-width: 50px;
            }
            
            .control-desc {
                font-size: 0.9rem;
            }
            
            .start-title {
                font-size: clamp(2rem, 12vw, 4rem);
            }
            
            .play-button {
                padding: 1.2rem 3rem;
                font-size: 1.3rem;
            }
            
            .game-info {
                font-size: 1rem;
                padding: 0 1rem;
            }
        }
        
        /* Extra small screens */
        @media (max-width: 480px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .control-item {
                flex-direction: row;
                justify-content: space-between;
                padding: 1rem 1.5rem;
            }
            
            .header {
                padding: 1rem;
            }
            
            .game-wrapper {
                padding: 0.5rem;
            }

            .left-stats, .right-info {
                max-width: none;
                width: 95%;
            }

            .stats-panel, .info-panel {
                padding: 0.8rem;
            }

            .stats-title, .info-title {
                font-size: 1rem;
                margin-bottom: 1rem;
            }

            .stat-value, .info-value {
                font-size: 1.1rem;
            }

            .game-layout {
                gap: 0.8rem;
            }
        }

        /* Landscape orientation adjustments */
        @media (max-width: 768px) and (orientation: landscape) {
            .game-layout {
                flex-direction: row;
                gap: 1rem;
            }

            .left-stats, .right-info {
                flex: 0 0 150px;
                width: auto;
            }

            .stats-panel, .info-panel {
                padding: 0.8rem;
            }

            .stat-item, .info-item {
                flex-direction: column;
                margin-bottom: 0.6rem;
                padding: 0.5rem;
            }

            .stat-value, .info-value {
                font-size: 1rem;
            }
        }

        /* Schermata iniziale */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a40 50%, #2d1b69 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.8s ease-in-out, transform 0.8s ease-in-out;
        }

        .start-screen.hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }

        .start-content {
            text-align: center;
            max-width: 600px;
            padding: 2rem;
        }

        .start-title {
            font-family: 'Orbitron', monospace;
            font-size: clamp(3rem, 10vw, 6rem);
            font-weight: 900;
            background: linear-gradient(45deg, #64ffda, #00bcd4, #2196f3, #9c27b0);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 50px rgba(100, 255, 218, 0.5);
            margin-bottom: 1rem;
        }

        .start-subtitle {
            font-size: 1.5rem;
            color: #b0bec5;
            margin-bottom: 2rem;
            font-weight: 300;
        }

        .play-button {
            background: linear-gradient(45deg, #64ffda, #2196f3);
            border: none;
            padding: 1.5rem 4rem;
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: #0f0f23;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 10px 30px rgba(100, 255, 218, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .play-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .play-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 
                0 20px 40px rgba(100, 255, 218, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.2);
        }

        .play-button:hover::before {
            left: 100%;
        }

        .play-button:active {
            transform: translateY(-2px) scale(1.02);
        }

        .start-instructions {
            margin-top: 2rem;
            color: #78909c;
            font-size: 1rem;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.7);
            padding: 1.2rem;
            border-radius: 12px;
            border: 2px solid #00ffaa;
            backdrop-filter: blur(10px);
        }
        
        /* Istruzioni specifiche per desktop */
        .desktop-instructions {
            background: rgba(30, 144, 255, 0.15);
            padding: 1rem;
            border-radius: 10px;
            border-left: 4px solid #1e90ff;
            margin: 0.8rem 0;
        }
        
        .desktop-instructions p {
            color: #87ceeb !important;
            font-size: 0.95rem;
            margin: 0;
            font-weight: 500;
        }
        
        /* Istruzioni specifiche per mobile */
        .mobile-instructions {
            background: rgba(255, 165, 0, 0.15);
            padding: 1rem;
            border-radius: 10px;
            border-left: 4px solid #ffa500;
            margin: 0.8rem 0;
        }
        
        .mobile-instructions p {
            color: #ffd700 !important;
            font-size: 0.95rem;
            margin: 0;
            font-weight: 500;
        }
        
        /* Obiettivo del gioco */
        .game-goal {
            color: #00ff88 !important;
            font-weight: bold;
            text-align: center;
            margin-top: 1.2rem !important;
            padding-top: 1rem;
            border-top: 2px solid rgba(0, 255, 136, 0.4);
            font-size: 1.05rem;
        }
        
        /* Mostra/nascondi istruzioni in base al dispositivo */
        @media (max-width: 768px) {
            .desktop-instructions {
                display: none;
            }
            
            .mobile-instructions {
                display: block;
            }
            
            .start-instructions {
                margin-top: 1.5rem;
                padding: 1rem;
            }
            
            .mobile-instructions p {
                font-size: 0.9rem;
            }
        }
        
        @media (min-width: 769px) {
            .desktop-instructions {
                display: block;
            }
            
            .mobile-instructions {
                display: none;
            }
        }
        
        /* Tablet specifico */
        @media (min-width: 768px) and (max-width: 1024px) {
            .start-instructions {
                padding: 1.5rem;
            }
            
            .desktop-instructions p,
            .mobile-instructions p {
                font-size: 1rem;
            }
            
            .game-goal {
                font-size: 1.1rem;
            }
        }

        .preview-blocks {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 2rem 0;
            opacity: 0.7;
        }

        .preview-block {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            animation: blockPulse 2s ease-in-out infinite;
        }

        .preview-block:nth-child(1) { background: #64ffda; animation-delay: 0s; }
        .preview-block:nth-child(2) { background: #2196f3; animation-delay: 0.3s; }
        .preview-block:nth-child(3) { background: #9c27b0; animation-delay: 0.6s; }
        .preview-block:nth-child(4) { background: #ff5722; animation-delay: 0.9s; }
        .preview-block:nth-child(5) { background: #4caf50; animation-delay: 1.2s; }

        @keyframes blockPulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        /* Nascondi il gioco inizialmente */
        .game-container {
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.8s ease-in-out;
            pointer-events: none;
        }

        .game-container.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        /* Mobile Instructions */
        .mobile-instructions {
            display: none;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 16px;
            padding: 1.5rem;
            margin: 1rem 0;
            border: 2px solid rgba(100, 255, 218, 0.3);
            backdrop-filter: blur(10px);
        }

        .mobile-instructions h3 {
            color: #64ffda;
            font-family: 'Orbitron', monospace;
            text-align: center;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .touch-controls {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .touch-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem;
            background: rgba(100, 255, 218, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }

        .touch-gesture {
            font-size: 1.1rem;
            font-weight: 600;
            color: #64ffda;
        }

        .touch-action {
            color: #ffffff;
            font-weight: 500;
        }

        .mobile-only {
            display: none;
        }

        /* Mobile game control help text and menu */
        .mobile-game-controls {
            display: none;
            justify-content: center;
            margin-top: 1rem;
            padding: 0 1rem;
        }
        
        .mobile-help-text {
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            color: rgba(100, 255, 218, 0.8);
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
        
        /* Mobile Pause Menu */
        .mobile-pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .mobile-pause-content {
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid #64ffda;
            border-radius: 20px;
            padding: 2rem;
            min-width: 250px;
            text-align: center;
        }
        
        .mobile-pause-menu.active {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }
        
        .mobile-pause-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: #64ffda;
            text-align: center;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px #64ffda;
        }
        
        .mobile-pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .mobile-btn {
            background: linear-gradient(135deg, #64ffda, #2196f3);
            border: none;
            padding: 0.8rem 1.5rem;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            font-weight: 600;
            color: #0f0f23;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.3);
            min-width: 120px;
        }

        .mobile-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(100, 255, 218, 0.4);
        }

        .mobile-btn:active {
            transform: translateY(0);
        }

        .pause-btn {
            background: linear-gradient(135deg, #ffb74d, #ff9800);
        }

        .restart-btn {
            background: linear-gradient(135deg, #81c784, #4caf50);
        }

        /* Mobile Game Over Overlay */
        .mobile-gameover-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 35, 0.98);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(15px);
        }
        
        /* Hide canvas on mobile when game over overlay is active */
        @media (max-width: 768px) {
            .mobile-gameover-overlay.active ~ * #canvas {
                visibility: hidden !important;
            }
        }

        .mobile-gameover-content {
            text-align: center;
            padding: 2rem;
            max-width: 90%;
        }

        .mobile-gameover-title {
            font-family: 'Orbitron', monospace;
            font-size: 3rem;
            font-weight: 900;
            color: #ff5722;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(255, 87, 34, 0.5);
        }

        .mobile-gameover-score {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: #64ffda;
            margin-bottom: 2rem;
        }

        .mobile-gameover-instruction {
            font-size: 1.2rem;
            color: #ffffff;
            margin-bottom: 1rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Desktop-only elements (hidden on mobile) */
        .desktop-only {
            display: block;
        }

        /* Show mobile elements on small screens */
        @media (max-width: 768px) {
            .mobile-instructions {
                display: block;
            }
            
            .mobile-only {
                display: flex;
            }
            
            .desktop-only {
                display: none !important;
            }
            
            .mobile-game-controls {
                display: flex !important;
            }
            
            .mobile-game-controls {
                display: flex !important;
            }
            
            .mobile-game-controls {
                display: flex !important;
            }
        }

        /* Desktop Pause Menu */
        .desktop-pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        
        .desktop-pause-content {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95), rgba(26, 26, 64, 0.95));
            backdrop-filter: blur(15px);
            border: 3px solid #64ffda;
            border-radius: 25px;
            padding: 3rem 2.5rem;
            min-width: 400px;
            max-width: 500px;
            text-align: center;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 0 1px rgba(100, 255, 218, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .desktop-pause-content::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #64ffda, #2196f3, #9c27b0, #64ffda);
            border-radius: 27px;
            z-index: -1;
            animation: borderGlow 3s linear infinite;
            background-size: 300% 300%;
        }
        
        .desktop-pause-menu.active {
            display: flex;
            animation: fadeInScale 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .desktop-pause-title {
            font-family: 'Orbitron', monospace;
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #64ffda, #00bcd4, #2196f3);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .desktop-pause-subtitle {
            color: #b0bec5;
            font-size: 1.1rem;
            margin-bottom: 2.5rem;
            font-weight: 300;
            opacity: 0.9;
        }
        
        .desktop-pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 1.2rem;
            margin-top: 1rem;
        }
        
        .desktop-pause-btn {
            background: linear-gradient(135deg, #64ffda, #2196f3);
            border: none;
            padding: 1rem 2rem;
            font-family: 'Orbitron', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            color: #0f0f23;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 
                0 8px 25px rgba(100, 255, 218, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 200px;
        }
        
        .desktop-pause-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .desktop-pause-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 12px 35px rgba(100, 255, 218, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        .desktop-pause-btn:hover::before {
            left: 100%;
        }
        
        .desktop-pause-btn:active {
            transform: translateY(-1px) scale(1.01);
        }
        
        .desktop-pause-btn.secondary {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            color: #64ffda;
            border: 2px solid #64ffda;
            box-shadow: 
                0 8px 25px rgba(100, 255, 218, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .desktop-pause-btn.secondary:hover {
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.2), rgba(100, 255, 218, 0.1));
            color: #ffffff;
            box-shadow: 
                0 12px 35px rgba(100, 255, 218, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        .desktop-pause-btn.danger {
            background: linear-gradient(135deg, #ff5722, #e64a19);
            color: #ffffff;
        }
        
        .desktop-pause-btn.danger:hover {
            background: linear-gradient(135deg, #ff6f47, #ff5722);
            box-shadow: 
                0 12px 35px rgba(255, 87, 34, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        .desktop-pause-stats {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 1rem;
            margin: 1.5rem 0;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }
        
        .desktop-pause-stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0.5rem 0;
        }
        
        .desktop-pause-stats-label {
            color: #b0bec5;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .desktop-pause-stats-value {
            color: #64ffda;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            font-size: 1rem;
        }
        
        /* ==================== MEDIA QUERIES PER MENU DI PAUSA ==================== */
        
        /* Menu di pausa - Tablet */
        @media (min-width: 769px) and (max-width: 1024px) {
            .desktop-pause-content {
                min-width: 350px;
                max-width: 450px;
                padding: 2.5rem 2rem;
            }
            
            .desktop-pause-title {
                font-size: 2rem;
            }
            
            .desktop-pause-btn {
                min-width: 180px;
                font-size: 1rem;
            }
        }
        
        /* Menu di pausa mobile - Large */
        @media (min-width: 481px) and (max-width: 768px) {
            .mobile-pause-content {
                min-width: 280px;
                padding: 2.5rem;
            }
            
            .mobile-pause-title {
                font-size: 1.8rem;
            }
            
            .mobile-btn {
                min-width: 150px;
                font-size: 1.1rem;
                padding: 1rem 1.8rem;
            }
        }
        
        /* Menu di pausa mobile - Small */
        @media (max-width: 480px) {
            .mobile-pause-content {
                min-width: 250px;
                padding: 2rem;
                margin: 1rem;
            }
            
            .mobile-pause-title {
                font-size: 1.6rem;
                margin-bottom: 1.2rem;
            }
            
            .mobile-btn {
                min-width: 140px;
                font-size: 1rem;
                padding: 0.9rem 1.5rem;
            }
        }
        
        /* Menu di pausa mobile - Extra Small */
        @media (max-width: 360px) {
            .mobile-pause-content {
                min-width: 220px;
                padding: 1.5rem;
                margin: 0.5rem;
            }
            
            .mobile-pause-title {
                font-size: 1.4rem;
                margin-bottom: 1rem;
            }
            
            .mobile-btn {
                min-width: 120px;
                font-size: 0.9rem;
                padding: 0.8rem 1.2rem;
            }
        }
        
        /* ==================== MEDIA QUERIES PER MENU DI PAUSA ==================== */
        
        /* Menu di pausa - Tablet */
        @media (min-width: 769px) and (max-width: 1024px) {
            .desktop-pause-content {
                min-width: 350px;
                max-width: 450px;
                padding: 2.5rem 2rem;
            }
            
            .desktop-pause-title {
                font-size: 2rem;
            }
            
            .desktop-pause-btn {
                min-width: 180px;
                font-size: 1rem;
            }
        }
        
        /* Menu di pausa mobile - Large */
        @media (min-width: 481px) and (max-width: 768px) {
            .mobile-pause-content {
                min-width: 280px;
                padding: 2.5rem;
            }
            
            .mobile-pause-title {
                font-size: 1.8rem;
            }
            
            .mobile-btn {
                min-width: 150px;
                font-size: 1.1rem;
                padding: 1rem 1.8rem;
            }
        }
        
        /* Menu di pausa mobile - Small */
        @media (max-width: 480px) {
            .mobile-pause-content {
                min-width: 250px;
                padding: 2rem;
                margin: 1rem;
            }
            
            .mobile-pause-title {
                font-size: 1.6rem;
                margin-bottom: 1.2rem;
            }
            
            .mobile-btn {
                min-width: 140px;
                font-size: 1rem;
                padding: 0.9rem 1.5rem;
            }
        }
        
        /* Menu di pausa mobile - Extra Small */
        @media (max-width: 360px) {
            .mobile-pause-content {
                min-width: 220px;
                padding: 1.5rem;
                margin: 0.5rem;
            }
            
            .mobile-pause-title {
                font-size: 1.4rem;
                margin-bottom: 1rem;
            }
            
            .mobile-btn {
                min-width: 120px;
                font-size: 0.9rem;
                padding: 0.8rem 1.2rem;
            }
        }
        
        /* Menu di pausa - iPad Portrait specifico */
        @media (min-width: 768px) and (max-width: 1024px) and (orientation: portrait) and (-webkit-min-device-pixel-ratio: 2) {
            .desktop-pause-content {
                min-width: 400px;
                max-width: 500px;
                padding: 3rem 2.5rem;
            }
            
            .desktop-pause-title {
                font-size: 2.5rem;
                margin-bottom: 2rem;
            }
            
            .desktop-pause-btn {
                min-width: 200px;
                font-size: 1.2rem;
                padding: 1.2rem 2rem;
                margin: 0.8rem 0;
            }
        }
        
        /* Menu di pausa - iPad Landscape specifico */
        @media (min-width: 1024px) and (max-width: 1366px) and (orientation: landscape) and (-webkit-min-device-pixel-ratio: 2) {
            .desktop-pause-content {
                min-width: 450px;
                max-width: 600px;
                padding: 2.5rem;
            }
            
            .desktop-pause-title { 
                font-size: 2.2rem;
            }
            
            .desktop-pause-btn {
                min-width: 220px;
                font-size: 1.1rem;
                padding: 1.1rem 1.8rem;
            }
        }
        
        /* Menu di pausa - Surface Pro e dispositivi simili */
        @media (min-width: 900px) and (max-width: 1400px) and (min-height: 800px) {
            .desktop-pause-content {
                min-width: 500px;
                max-width: 650px;
                padding: 3rem 2.5rem;
            }
            
            .desktop-pause-title {
                font-size: 2.5rem;
                margin-bottom: 2rem;
            }
            
            .desktop-pause-btn {
                min-width: 240px;
                font-size: 1.3rem;
                padding: 1.3rem 2.2rem;
                margin: 1rem 0;
            }
        }
        
        /* Menu di pausa - Dispositivi pieghevoli e ultra-wide */
        @media (min-width: 1400px) {
            .desktop-pause-content {
                min-width: 600px;
                max-width: 800px;
                padding: 3.5rem 3rem;
            }
            
            .desktop-pause-title {
                font-size: 3rem;
                margin-bottom: 2.5rem;
            }
            
            .desktop-pause-btn {
                min-width: 280px;
                font-size: 1.4rem;
                padding: 1.5rem 2.5rem;
                margin: 1.2rem 0;
            }
        }
        
        /* Desktop only - hide on mobile */
        @media (max-width: 768px) {
            .desktop-pause-menu {
                display: none !important;
            }
        }

        /* ==================== CONTROLLI AUDIO ==================== */
        
        .audio-controls {
            margin-top: 0; /* Rimuovo il margin per usare il gap del parent */
            position: relative;
            touch-action: manipulation; /* Previeni comportamenti touch indesiderati */
        }
        
        .volume-slider {
            touch-action: manipulation; /* Permetti solo pan-x per lo slider */
        }
        
        .mute-btn {
            touch-action: manipulation; /* Previeni double-tap zoom */
        }
        
        /* Forza il corretto posizionamento dei pannelli info */
        .right-info {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .right-info .info-panel {
            position: relative;
            z-index: 1;
        }
        
        .volume-control {
            flex-direction: column !important;
            align-items: stretch !important;
        }
        
        .volume-slider-container {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-top: 0.5rem;
        }
        
        .volume-slider {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(45deg, #64ffda, #2196f3);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(100, 255, 218, 0.4);
            transition: all 0.3s ease;
        }
        
        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.6);
        }
        
        .volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(45deg, #64ffda, #2196f3);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(100, 255, 218, 0.4);
            transition: all 0.3s ease;
        }
        
        .volume-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.6);
        }
        
        .volume-slider::-moz-range-track {
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            border: none;
        }
        
        .volume-value {
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            font-weight: 600;
            color: #64ffda;
            min-width: 35px;
            text-align: center;
            background: rgba(100, 255, 218, 0.1);
            padding: 0.2rem 0.5rem;
            border-radius: 8px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
        
        .mute-control {
            justify-content: center !important;
        }
        
        .mute-btn {
            background: linear-gradient(135deg, #64ffda, #2196f3);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            color: #0f0f23;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.3);
            min-width: 100px;
            justify-content: center;
        }
        
        .mute-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(100, 255, 218, 0.4);
        }
        
        .mute-btn:active {
            transform: translateY(0);
        }
        
        .mute-btn.muted {
            background: linear-gradient(135deg, #ff5722, #e64a19);
            color: #ffffff;
        }
        
        .mute-btn.muted:hover {
            box-shadow: 0 6px 20px rgba(255, 87, 34, 0.4);
        }
        
        .mute-icon {
            font-size: 1.1rem;
        }
        
        .mute-text {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Mobile adjustments per controlli audio */
        @media (max-width: 768px) {
            .audio-controls {
                /* Rimuovi l'order che sposta i controlli in cima */
                margin-bottom: 1rem;
                margin-top: 1rem;
            }
            
            .volume-control {
                padding: 1rem;
            }
            
            .volume-slider-container {
                gap: 1rem;
            }
            
            .volume-slider {
                height: 8px;
            }
            
            .volume-slider::-webkit-slider-thumb {
                width: 20px;
                height: 20px;
            }
            
            .volume-slider::-moz-range-thumb {
                width: 20px;
                height: 20px;
            }
            
            .volume-value {
                font-size: 1rem;
                min-width: 40px;
                padding: 0.3rem 0.6rem;
            }
            
            .mute-btn {
                padding: 1rem 2rem;
                font-size: 1rem;
                min-width: 120px;
            }
            
            .mute-icon {
                font-size: 1.2rem;
            }
            
            .mute-text {
                font-size: 0.9rem;
            }
        }

        /* ==================== NUOVA SCHERMATA GAME OVER ==================== */
        
        /* Overlay principale */
        .gameover-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(15, 15, 35, 0.98);
            backdrop-filter: blur(20px);
            animation: gameOverFadeIn 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .gameover-overlay.active {
            display: flex;
        }
        
        @keyframes gameOverFadeIn {
            from {
                opacity: 0;
                background: rgba(15, 15, 35, 0);
            }
            to {
                opacity: 1;
                background: rgba(15, 15, 35, 0.98);
            }
        }
        
        /* Sfondo animato */
        .gameover-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }
        
        .gameover-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .falling-block {
            position: absolute;
            width: 12px;
            height: 12px;
            top: -20px;
            background: linear-gradient(45deg, #ff5722, #ff9800);
            border-radius: 2px;
            opacity: 0.15;
            animation: fallDown 8s linear infinite;
        }
        
        .falling-block:nth-child(odd) {
            background: linear-gradient(45deg, #64ffda, #2196f3);
        }
        
        .falling-block:nth-child(3n) {
            background: linear-gradient(45deg, #9c27b0, #e91e63);
        }
        
        .falling-block:nth-child(4n) {
            background: linear-gradient(45deg, #4caf50, #8bc34a);
        }
        
        @keyframes fallDown {
            0% {
                transform: translateY(-20px) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.4;
            }
            90% {
                opacity: 0.4;
            }
            100% {
                transform: translateY(calc(100vh + 20px)) rotate(360deg);
                opacity: 0;
            }
        }
        
        /* Contenuto principale */
        .gameover-content {
            position: relative;
            z-index: 10;
            max-width: 600px;
            width: 90%;
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98), rgba(26, 26, 64, 0.98));
            backdrop-filter: blur(15px);
            border-radius: 25px;
            border: 3px solid transparent;
            background-clip: padding-box;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.7),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                0 0 0 1px rgba(0, 0, 0, 0.8);
            animation: gameOverSlideIn 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.2s both;
        }
        
        .gameover-content::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #ff5722, #ff9800, #64ffda, #2196f3, #9c27b0);
            background-size: 300% 300%;
            border-radius: 25px;
            z-index: -1;
            animation: borderRainbow 4s linear infinite;
        }
        
        @keyframes gameOverSlideIn {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes borderRainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Titolo Game Over */
        .gameover-title {
            font-family: 'Orbitron', monospace;
            font-size: clamp(2.5rem, 8vw, 4rem);
            font-weight: 900;
            margin-bottom: 1rem;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .gameover-text {
            background: linear-gradient(45deg, #ff5722, #ff9800, #ffeb3b);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 2s ease-in-out infinite alternate;
            text-shadow: 
                0 0 30px rgba(255, 87, 34, 0.8),
                0 0 10px rgba(0, 0, 0, 0.8),
                2px 2px 4px rgba(0, 0, 0, 0.9);
            display: inline-block;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.8));
        }
        
        .gameover-text:nth-child(2) {
            animation-delay: 0.5s;
        }
        
        @keyframes titleGlow {
            0% {
                background-position: 0% 50%;
                filter: brightness(1);
            }
            100% {
                background-position: 100% 50%;
                filter: brightness(1.2);
            }
        }
        
        /* Sottotitolo */
        .gameover-subtitle {
            font-size: 1.2rem;
            color: #e0e0e0;
            margin-bottom: 2rem;
            font-weight: 400;
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 0 8px rgba(0, 0, 0, 0.6);
            opacity: 0;
            animation: subtitleFadeIn 0.6s ease-out 0.8s both;
        }
        
        @keyframes subtitleFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Statistiche */
        .gameover-stats {
            margin-bottom: 2rem;
            opacity: 0;
            animation: statsFadeIn 0.8s ease-out 1s both;
        }
        
        @keyframes statsFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .stat-card {
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 1rem;
            border: 2px solid rgba(100, 255, 218, 0.4);
            transition: all 0.3s ease;
            backdrop-filter: blur(15px);
            box-shadow: 
                0 4px 15px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .stat-card:hover {
            transform: translateY(-3px);
            border-color: rgba(100, 255, 218, 0.6);
            box-shadow: 0 8px 25px rgba(100, 255, 218, 0.2);
        }
        
        .stat-card.primary {
            border-color: rgba(255, 193, 7, 0.6);
            background: rgba(255, 193, 7, 0.1);
        }
        
        .stat-card.primary:hover {
            border-color: rgba(255, 193, 7, 0.8);
            box-shadow: 0 8px 25px rgba(255, 193, 7, 0.3);
        }
        
        .stat-icon {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #b0bec5;
            margin-bottom: 0.5rem;
            font-weight: 500;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.7);
        }
        
        .stat-number {
            font-family: 'Orbitron', monospace;
            font-size: 1.4rem;
            font-weight: 700;
            color: #ffffff;
            background: linear-gradient(45deg, #64ffda, #00bcd4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .stat-card.primary .stat-number {
            background: linear-gradient(45deg, #ffc107, #ff9800);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* Sezione Record */
        .record-section {
            margin-top: 1.5rem;
        }
        
        .record-card {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            padding: 1.2rem;
            border: 2px solid rgba(255, 193, 7, 0.5);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .record-card.new-record {
            border-color: #ffc107;
            background: rgba(255, 193, 7, 0.15);
            animation: recordPulse 2s ease-in-out infinite;
        }
        
        @keyframes recordPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 193, 7, 0.3);
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 193, 7, 0.6);
            }
        }
        
        .record-icon {
            font-size: 2rem;
            filter: drop-shadow(0 0 10px rgba(255, 193, 7, 0.6));
        }
        
        .record-text {
            text-align: left;
        }
        
        .record-label {
            font-size: 0.9rem;
            color: #b0bec5;
            margin-bottom: 0.3rem;
            font-weight: 500;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }
        
        .record-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.6rem;
            font-weight: 700;
            background: linear-gradient(45deg, #ffc107, #ff9800);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .record-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: linear-gradient(45deg, #ffc107, #ff9800);
            color: #0f0f23;
            font-size: 0.7rem;
            font-weight: 700;
            padding: 0.3rem 0.6rem;
            border-radius: 15px;
            transform: rotate(15deg);
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4);
            display: none;
        }
        
        .record-card.new-record .record-badge {
            display: block;
            animation: badgeBounce 1s ease-in-out infinite;
        }
        
        @keyframes badgeBounce {
            0%, 100% { transform: rotate(15deg) scale(1); }
            50% { transform: rotate(15deg) scale(1.1); }
        }
        
        /* Messaggio motivazionale */
        .gameover-message {
            font-size: 1.1rem;
            color: #e0e0e0;
            margin-bottom: 2rem;
            line-height: 1.5;
            font-style: italic;
            font-weight: 400;
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 0 8px rgba(0, 0, 0, 0.6);
            opacity: 0;
            animation: messageFadeIn 0.6s ease-out 1.4s both;
        }
        
        @keyframes messageFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Pulsanti */
        .gameover-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            opacity: 0;
            animation: actionsFadeIn 0.8s ease-out 1.6s both;
        }
        
        @keyframes actionsFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .gameover-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem 2rem;
            border: none;
            border-radius: 25px;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 180px;
            justify-content: center;
        }
        
        .gameover-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .gameover-btn:hover::before {
            left: 100%;
        }
        
        .gameover-btn.primary {
            background: linear-gradient(135deg, #64ffda, #2196f3);
            color: #0f0f23;
            box-shadow: 0 8px 25px rgba(100, 255, 218, 0.3);
        }
        
        .gameover-btn.primary:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 12px 35px rgba(100, 255, 218, 0.4);
        }
        
        .gameover-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #64ffda;
            border: 2px solid #64ffda;
            box-shadow: 0 8px 25px rgba(100, 255, 218, 0.2);
        }
        
        .gameover-btn.secondary:hover {
            background: rgba(100, 255, 218, 0.2);
            color: #ffffff;
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 12px 35px rgba(100, 255, 218, 0.3);
        }
        
        .gameover-btn:active {
            transform: translateY(-1px) scale(1.01);
        }
        
        .btn-icon {
            font-size: 1.2rem;
        }
        
        /* Istruzioni */
        .gameover-instructions {
            opacity: 0;
            animation: instructionsFadeIn 0.6s ease-out 2s both;
        }
        
        @keyframes instructionsFadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 0.7;
            }
        }
        
        .desktop-instruction,
        .mobile-instruction {
            font-size: 0.9rem;
            color: #b0bec5;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .desktop-instruction kbd {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 0.2rem 0.4rem;
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            color: #64ffda;
        }
        
        .mobile-instruction {
            display: none;
        }
        
        /* Compatibilità overlay legacy mobile */
        .legacy-mobile {
            display: none !important;
        }
        
        /* ==================== MEDIA QUERIES DETTAGLIATE ==================== */
        
        /* ==================== MEDIA QUERIES SPECIFICHE PER IPAD ==================== */
        
        /* iPad Mini (768x1024) Portrait */
        @media (min-width: 768px) and (max-width: 768px) and (orientation: portrait) {
            .gameover-content {
                max-width: 600px;
                width: 80%;
                padding: 2rem;
            }
            
            .gameover-title {
                font-size: clamp(2.5rem, 5vw, 3.2rem);
                margin-bottom: 1.2rem;
            }
            
            .gameover-subtitle {
                font-size: 1.3rem;
                margin-bottom: 2rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1.2rem;
            }
            
            .stat-card {
                padding: 1.2rem;
            }
            
            .stat-icon {
                font-size: 1.6rem;
            }
            
            .stat-number {
                font-size: 1.6rem;
            }
            
            .gameover-actions {
                flex-direction: column;
                gap: 1.5rem;
                align-items: center;
            }
            
            .gameover-btn {
                width: 100%;
                max-width: 350px;
                font-size: 1.2rem;
                padding: 1.3rem 2rem;
            }
            
            .record-card {
                padding: 1.5rem;
                flex-direction: row;
            }
            
            .gameover-message {
                font-size: 1.2rem;
                margin-bottom: 2rem;
            }
        }
        
        /* iPad Standard (769px-820px) e iPad Air Portrait */
        @media (min-width: 769px) and (max-width: 820px) and (orientation: portrait) {
            .gameover-content {
                max-width: 650px;
                width: 85%;
                padding: 2.2rem;
            }
            
            .gameover-title {
                font-size: clamp(2.8rem, 5vw, 3.5rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1.3rem;
            }
            
            .stat-card {
                padding: 1.3rem;
            }
            
            .gameover-actions {
                flex-direction: column;
                gap: 1.5rem;
            }
            
            .gameover-btn {
                width: 100%;
                max-width: 400px;
                font-size: 1.2rem;
                padding: 1.4rem 2.2rem;
            }
        }
        
        /* iPad Pro 11" (821px-834px) Portrait */
        @media (min-width: 821px) and (max-width: 834px) and (orientation: portrait) {
            .gameover-content {
                max-width: 700px;
                width: 85%;
                padding: 2.5rem;
            }
            
            .gameover-title {
                font-size: clamp(3rem, 5vw, 3.8rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1.5rem;
            }
            
            .stat-card {
                padding: 1.5rem;
            }
            
            .gameover-btn {
                width: 100%;
                max-width: 450px;
                font-size: 1.3rem;
                padding: 1.5rem 2.5rem;
            }
        }
        
        /* iPad Pro 12.9" (835px-1024px) Portrait */
        @media (min-width: 835px) and (max-width: 1024px) and (orientation: portrait) {
            .gameover-content {
                max-width: 800px;
                width: 80%;
                padding: 3rem;
            }
            
            .gameover-title {
                font-size: clamp(3.2rem, 4vw, 4rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 1.8rem;
            }
            
            .stat-card {
                padding: 1.8rem;
            }
            
            .stat-icon {
                font-size: 2rem;
            }
            
            .stat-number {
                font-size: 2rem;
            }
            
            .gameover-actions {
                flex-direction: row;
                gap: 2rem;
                justify-content: center;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 300px;
                font-size: 1.4rem;
                padding: 1.6rem 2.8rem;
            }
            
            .record-card {
                padding: 2rem;
            }
        }
        
        /* Mobile Large (481px - 768px) */
        @media (min-width: 481px) and (max-width: 768px) {
            .gameover-content {
                width: 90%;
                padding: 1.6rem;
                max-width: 450px;
            }
            
            .gameover-title {
                font-size: clamp(2rem, 8vw, 3rem);
                margin-bottom: 1rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.9rem;
            }
            
            .stat-card {
                padding: 0.9rem;
            }
            
            .stat-icon {
                font-size: 1.3rem;
            }
            
            .stat-number {
                font-size: 1.3rem;
            }
            
            .record-card {
                flex-direction: row;
                text-align: left;
                padding: 1.1rem;
            }
            
            .gameover-actions {
                flex-direction: column;
                align-items: center;
                gap: 1rem;
            }
            
            .gameover-btn {
                width: 100%;
                max-width: 300px;
                padding: 1.1rem 1.8rem;
                font-size: 1.1rem;
            }
        }
        
        /* Mobile Standard (max-width: 480px) */
        @media (max-width: 480px) {
            .gameover-content {
                width: 95%;
                padding: 1.5rem;
                max-width: none;
            }
            
            .gameover-title {
                font-size: clamp(1.8rem, 9vw, 2.6rem);
                margin-bottom: 0.8rem;
            }
            
            .gameover-subtitle {
                font-size: 1.05rem;
                margin-bottom: 1.4rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.8rem;
            }
            
            .stat-card {
                padding: 0.8rem;
            }
            
            .stat-icon {
                font-size: 1.2rem;
            }
            
            .stat-number {
                font-size: 1.2rem;
            }
            
            .record-card {
                flex-direction: column;
                padding: 1rem;
            }
            
            .gameover-actions {
                gap: 0.9rem;
            }
            
            .gameover-btn {
                font-size: 1rem;
                padding: 1.1rem 1.6rem;
            }
            
            .gameover-message {
                font-size: 1.05rem;
            }
            
            .desktop-instruction {
                display: none;
            }
            
            .mobile-instruction {
                display: block;
            }
            
            .record-card {
                flex-direction: column;
                text-align: center;
                padding: 1rem;
            }
            
            .record-text {
                text-align: center;
            }
            
            .gameover-actions {
                flex-direction: column;
                align-items: center;
            }
            
            .gameover-btn {
                width: 100%;
                max-width: 280px;
                padding: 1.2rem 1.5rem;
            }
        }
        
        /* ==================== FINE MOBILE STANDARD ==================== */
        
        /* Mobile Small (361px - 480px) */
        @media (min-width: 361px) and (max-width: 480px) {
            .gameover-content {
                padding: 1.2rem;
                width: 96%;
            }
            
            .gameover-title {
                font-size: clamp(1.9rem, 9vw, 2.8rem);
                gap: 0.4rem;
                margin-bottom: 0.8rem;
            }
            
            .gameover-subtitle {
                font-size: 1.1rem;
                margin-bottom: 1.5rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.7rem;
            }
            
            .stat-card {
                padding: 0.8rem;
            }
            
            .stat-icon {
                font-size: 1.1rem;
            }
            
            .stat-number {
                font-size: 1.1rem;
            }
            
            .record-card {
                flex-direction: column;
                text-align: center;
                padding: 1rem;
            }
            
            .gameover-actions {
                gap: 0.9rem;
            }
            
            .gameover-btn {
                font-size: 1rem;
                padding: 1.1rem 1.5rem;
            }
            
            .gameover-message {
                font-size: 1.05rem;
            }
        }
        
        /* Mobile Extra Small (max-width: 360px) */
        @media (max-width: 360px) {
            .gameover-content {
                padding: 1rem;
                width: 98%;
                margin: 0.5rem;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
                gap: 0.6rem;
            }
            
            .stat-card {
                padding: 0.7rem;
                display: flex;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                text-align: left;
            }
            
            .stat-icon {
                font-size: 1.2rem;
                margin-bottom: 0;
                margin-right: 0.5rem;
            }
            
            .stat-content {
                display: flex;
                flex-direction: column;
                flex: 1;
                margin-left: 0.5rem;
            }
            
            .stat-label {
                margin-bottom: 0.2rem;
                font-size: 0.8rem;
            }
            
            .stat-number {
                font-size: 1rem;
            }
            
            .gameover-actions {
                gap: 0.8rem;
            }
            
            .gameover-btn {
                font-size: 0.9rem;
                padding: 1rem 1.2rem;
            }
            
            .falling-block {
                width: 6px;
                height: 6px;
            }
            
            .gameover-title {
                font-size: clamp(1.6rem, 10vw, 2.2rem);
                gap: 0.2rem;
                margin-bottom: 0.6rem;
            }
            
            .gameover-subtitle {
                font-size: 0.95rem;
                margin-bottom: 1.2rem;
            }
            
            .gameover-message {
                font-size: 0.95rem;
                margin-bottom: 1.5rem;
            }
            
            .record-card {
                flex-direction: column;
                padding: 0.9rem;
            }
            
            .record-icon {
                font-size: 1.5rem;
            }
            
            .record-value {
                font-size: 1.3rem;
            }
        }
        
        /* Landscape Orientation - Mobile Large */
        @media (min-width: 481px) and (max-width: 768px) and (orientation: landscape) {
            .gameover-content {
                max-height: 85vh;
                overflow-y: auto;
                padding: 1.2rem;
                width: 95%;
                max-width: 600px;
            }
            
            .gameover-title {
                font-size: clamp(1.8rem, 6vw, 2.5rem);
                margin-bottom: 0.8rem;
            }
            
            .gameover-subtitle {
                font-size: 1rem;
                margin-bottom: 1.2rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.6rem;
            }
            
            .stat-card {
                padding: 0.6rem;
            }
            
            .stat-icon {
                font-size: 1rem;
            }
            
            .stat-number {
                font-size: 1rem;
            }
            
            .record-card {
                padding: 0.9rem;
                flex-direction: row;
            }
            
            .gameover-actions {
                flex-direction: row;
                gap: 1rem;
            }
            
            .gameover-btn {
                flex: 1;
                min-width: auto;
                font-size: 0.9rem;
                padding: 0.8rem 1rem;
            }
            
            .gameover-message {
                font-size: 1rem;
                margin-bottom: 1.2rem;
            }
        }
        
        /* Landscape Orientation - Mobile Small */
        @media (max-width: 480px) and (orientation: landscape) and (max-height: 500px) {
            .gameover-content {
                max-height: 90vh;
                overflow-y: auto;
                padding: 0.8rem;
                width: 98%;
            }
            
            .gameover-title {
                font-size: clamp(1.4rem, 8vw, 2rem);
                margin-bottom: 0.5rem;
            }
            
            .gameover-subtitle {
                font-size: 0.9rem;
                margin-bottom: 1rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.4rem;
            }
            
            .stat-card {
                padding: 0.4rem;
            }
            
            .stat-icon {
                font-size: 0.9rem;
            }
            
            .stat-label {
                font-size: 0.7rem;
            }
            
            .stat-number {
                font-size: 0.9rem;
            }
            
            .record-card {
                padding: 0.6rem;
                flex-direction: row;
            }
            
            .record-icon {
                font-size: 1.2rem;
            }
            
            .record-value {
                font-size: 1.1rem;
            }
            
            .gameover-actions {
                flex-direction: row;
                gap: 0.8rem;
            }
            
            .gameover-btn {
                flex: 1;
                min-width: auto;
                font-size: 0.8rem;
                padding: 0.7rem 0.8rem;
            }
            
            .gameover-message {
                font-size: 0.9rem;
                margin-bottom: 1rem;
            }
            
            .falling-block {
                animation-duration: 5s;
                width: 6px;
                height: 6px;
            }
        }
        
        /* ==================== DISPOSITIVI SPECIFICI AD ALTA RISOLUZIONE ==================== */
        
        /* iPad Air 4/5 (820x1180) Portrait - Dimensioni specifiche */
        @media (min-width: 820px) and (max-width: 820px) and (min-height: 1180px) and (max-height: 1180px) and (orientation: portrait) {
            .gameover-content {
                max-width: 700px;
                width: 80%;
                padding: 2.5rem;
            }
            
            .gameover-title {
                font-size: clamp(3rem, 4.5vw, 3.8rem);
                margin-bottom: 1.5rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1.5rem;
            }
            
            .stat-card {
                padding: 1.5rem;
            }
            
            .stat-icon {
                font-size: 1.8rem;
            }
            
            .stat-number {
                font-size: 1.8rem;
            }
            
            .gameover-btn {
                width: 100%;
                max-width: 400px;
                font-size: 1.3rem;
                padding: 1.4rem 2.5rem;
            }
        }
        
        /* iPad Pro 11" (834x1194) - Dimensioni esatte */
        @media (min-width: 834px) and (max-width: 834px) and (min-height: 1194px) and (max-height: 1194px) and (orientation: portrait) {
            .gameover-content {
                max-width: 750px;
                width: 85%;
                padding: 2.8rem;
            }
            
            .gameover-title {
                font-size: clamp(3.2rem, 4vw, 4rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1.8rem;
            }
            
            .stat-card {
                padding: 1.8rem;
            }
            
            .stat-icon {
                font-size: 2rem;
            }
            
            .stat-number {
                font-size: 2rem;
            }
        }
        
        /* iPad Pro 12.9" (1024x1366) - Dimensioni esatte */
        @media (min-width: 1024px) and (max-width: 1024px) and (min-height: 1366px) and (max-height: 1366px) and (orientation: portrait) {
            .gameover-content {
                max-width: 900px;
                width: 80%;
                padding: 3.5rem;
            }
            
            .gameover-title {
                font-size: clamp(3.5rem, 3.5vw, 4.5rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 2rem;
            }
            
            .stat-card {
                padding: 2rem;
            }
            
            .stat-icon {
                font-size: 2.2rem;
            }
            
            .stat-number {
                font-size: 2.2rem;
            }
            
            .gameover-actions {
                flex-direction: row;
                gap: 2.5rem;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 350px;
                font-size: 1.5rem;
                padding: 1.8rem 3rem;
            }
        }
        
        /* Surface Pro 7 (1368x912) Portrait e simili */
        @media (min-width: 912px) and (max-width: 1368px) and (min-height: 912px) and (max-height: 1368px) {
            .gameover-content {
                max-width: 850px;
                width: 85%;
                padding: 2.5rem;
                max-height: 85vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(2.8rem, 3.5vw, 3.8rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 1.5rem;
            }
            
            .stat-card {
                padding: 1.5rem;
            }
            
            .stat-icon {
                font-size: 1.6rem;
            }
            
            .stat-number {
                font-size: 1.6rem;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 280px;
                font-size: 1.2rem;
                padding: 1.3rem 2.2rem;
            }
        }
        
        /* ASUS ZenBook Fold e dispositivi pieghevoli (1024x1536 piegato) */
        @media (min-width: 1024px) and (max-width: 1024px) and (min-height: 1536px) and (max-height: 1536px) {
            .gameover-content {
                max-width: 900px;
                width: 80%;
                padding: 3rem;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(3.2rem, 3vw, 4.2rem);
                margin-bottom: 2rem;
            }
            
            .gameover-subtitle {
                font-size: 1.5rem;
                margin-bottom: 2.5rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 2rem;
            }
            
            .stat-card {
                padding: 2.2rem;
            }
            
            .stat-icon {
                font-size: 2.5rem;
            }
            
            .stat-number {
                font-size: 2.5rem;
            }
            
            .stat-label {
                font-size: 1.1rem;
            }
            
            .record-card {
                padding: 2.5rem;
                margin: 2rem 0;
            }
            
            .record-icon {
                font-size: 3rem;
            }
            
            .record-value {
                font-size: 2.8rem;
            }
            
            .gameover-message {
                font-size: 1.4rem;
                margin-bottom: 2.5rem;
            }
            
            .gameover-actions {
                flex-direction: column;
                gap: 2rem;
            }
            
            .gameover-btn {
                width: 100%;
                max-width: 500px;
                font-size: 1.4rem;
                padding: 1.8rem 3rem;
            }
        }
        
        /* ==================== FIX SPECIFICI PER IPAD ==================== */
        
        /* Compensazione per barre di navigazione iPad */
        @media (min-width: 768px) and (max-width: 1366px) and (-webkit-min-device-pixel-ratio: 2) {
            .gameover-overlay {
                padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            }
            
            .gameover-content {
                margin-top: max(1rem, env(safe-area-inset-top));
                margin-bottom: max(1rem, env(safe-area-inset-bottom));
            }
        }
        
        /* Fix per iPad in modalità Split View */
        @media (min-width: 320px) and (max-width: 678px) {
            .gameover-content {
                width: 95%;
                padding: 1.5rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.8rem;
            }
            
            .gameover-actions {
                flex-direction: column;
            }
            
            .gameover-btn {
                width: 100%;
                max-width: none;
            }
        }
        
        /* Fix per iPad con tastiera virtuale */
        @media (min-width: 768px) and (max-height: 600px) and (orientation: landscape) {
            .gameover-content {
                max-height: 90vh;
                overflow-y: auto;
                padding: 1rem;
            }
            
            .gameover-title {
                font-size: clamp(1.8rem, 4vw, 2.5rem);
                margin-bottom: 0.8rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.8rem;
            }
            
            .stat-card {
                padding: 0.8rem;
            }
            
            .gameover-btn {
                padding: 1rem 1.5rem;
                font-size: 0.95rem;
            }
        }
        
        /* ==================== FALLBACK PER DISPOSITIVI SIMILI ==================== */
        
        /* Tablet di fascia alta generici (800-900px width) */
        @media (min-width: 800px) and (max-width: 900px) and (min-height: 1000px) {
            .gameover-content {
                max-width: 750px;
                width: 85%;
                padding: 2.5rem;
            }
            
            .gameover-title {
                font-size: clamp(2.8rem, 4vw, 3.5rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1.5rem;
            }
            
            .stat-card {
                padding: 1.5rem;
            }
            
            .stat-icon {
                font-size: 1.7rem;
            }
            
            .stat-number {
                font-size: 1.7rem;
            }
            
            .gameover-btn {
                width: 100%;
                max-width: 400px;
                font-size: 1.2rem;
                padding: 1.4rem 2.3rem;
            }
        }
        
        /* Tablet professionali landscape (1200-1400px width) */
        @media (min-width: 1200px) and (max-width: 1400px) and (min-height: 800px) and (max-height: 1000px) and (orientation: landscape) {
            .gameover-content {
                max-width: 1150px;
                width: 85%;
                padding: 2.2rem;
                max-height: 85vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(2.6rem, 3vw, 3.4rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 1.3rem;
            }
            
            .stat-card {
                padding: 1.3rem;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 270px;
                font-size: 1.1rem;
                padding: 1.2rem 2rem;
            }
        }
        
        /* Dispositivi ad altissima risoluzione (>1400px) */
        @media (min-width: 1400px) and (max-height: 1100px) {
            .gameover-content {
                max-width: 1300px;
                width: 80%;
                padding: 2.8rem;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(3rem, 2.5vw, 4rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 1.8rem;
            }
            
            .stat-card {
                padding: 1.8rem;
            }
            
            .stat-icon {
                font-size: 1.8rem;
            }
            
            .stat-number {
                font-size: 1.8rem;
            }
            
            .gameover-actions {
                flex-direction: row;
                gap: 2.5rem;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 350px;
                font-size: 1.3rem;
                padding: 1.5rem 2.8rem;
            }
        }
        
        /* Fix per schermi con pixel ratio alto */
        @media (-webkit-min-device-pixel-ratio: 2.5), (min-resolution: 240dpi) {
            .gameover-text {
                text-shadow: 
                    0 0 35px rgba(255, 87, 34, 0.9),
                    0 0 12px rgba(0, 0, 0, 0.95),
                    2px 2px 4px rgba(0, 0, 0, 0.9);
            }
            
            .stat-card,
            .record-card {
                border-width: 1.5px;
                box-shadow: 
                    0 8px 32px rgba(0, 0, 0, 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            
            .gameover-btn {
                border-width: 2px;
                box-shadow: 
                    0 6px 20px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }
        
        /* ==================== DESKTOP GAME OVER OTTIMIZZATO ==================== */
        
        /* Desktop standard (1025px+) */
        @media (min-width: 1025px) and (max-height: 900px) {
            .gameover-content {
                max-width: 900px;
                width: 70%;
                padding: 2rem;
                max-height: none;
                overflow: visible;
                overflow-y: visible;
                margin: auto;
            }
            
            .gameover-title {
                font-size: clamp(2.5rem, 4vw, 3.5rem);
                text-align: center;
                margin-bottom: 1.5rem;
            }
            
            .gameover-subtitle {
                text-align: center;
                font-size: 1.2rem;
                margin-bottom: 2rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 1.5rem;
                justify-content: center;
                max-width: 800px;
                margin: 0 auto 2rem auto;
            }
            
            .stat-card {
                padding: 1.5rem;
                text-align: center;
                margin: 0;
            }
            
            .stat-icon {
                font-size: 1.8rem;
                margin-bottom: 0.5rem;
            }
            
            .stat-number {
                font-size: 1.8rem;
                font-weight: bold;
            }
            
            .stat-label {
                font-size: 0.9rem;
                text-align: center;
            }
            
            .record-card {
                max-width: 600px;
                margin: 2rem auto;
                padding: 1.5rem;
                text-align: center;
                flex-direction: row;
                justify-content: center;
                align-items: center;
                gap: 1rem;
            }
            
            .record-icon {
                font-size: 2.5rem;
            }
            
            .record-value {
                font-size: 2.2rem;
            }
            
            .gameover-message {
                font-size: 1.2rem;
                text-align: center;
                margin: 2rem auto;
                max-width: 600px;
            }
            
            .gameover-actions {
                flex-direction: row;
                gap: 2rem;
                justify-content: center;
                max-width: 500px;
                margin: 0 auto;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 200px;
                font-size: 1.1rem;
                padding: 1.2rem 2rem;
            }
        }
        
        /* Desktop wide (1400px+) */
        @media (min-width: 1400px) {
            .gameover-content {
                max-width: 1000px;
                width: 60%;
                padding: 2.5rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 2rem;
                max-width: 900px;
            }
            
            .stat-card {
                padding: 2rem;
            }
            
            .stat-icon {
                font-size: 2rem;
            }
            
            .stat-number {
                font-size: 2rem;
            }
            
            .gameover-btn {
                max-width: 250px;
                font-size: 1.2rem;
                padding: 1.3rem 2.2rem;
            }
        }
        
        /* Fix generale per desktop - rimuove completamente scroll */
        @media (min-width: 1025px) {
            .gameover-overlay {
                overflow: hidden;
                overflow-y: hidden;
                padding: 1rem;
            }
            
            .gameover-content {
                overflow: visible;
                overflow-y: visible;
                max-height: 90vh;
                height: auto;
            }
            
            .stats-grid {
                justify-items: center;
                place-items: center;
            }
            
            .stat-card {
                justify-self: center;
                align-self: center;
            }
        }
        
        /* Override per tutte le media query desktop che hanno overflow-y: auto */
        @media (min-width: 1025px) {
            /* iPad Mini/Standard Landscape */
            .gameover-content {
                overflow-y: visible !important;
                max-height: none !important;
            }
        }
        
        /* ==================== SUPPORTO TOUCH E ALTA DENSITÀ ==================== */
        
        /* Touch feedback per mobile */
        @media (hover: none) and (pointer: coarse) {
            .gameover-btn:active {
                transform: translateY(0) scale(0.98);
                transition: transform 0.1s ease;
            }
            
            .stat-card:active {
                transform: translateY(0) scale(0.98);
                transition: transform 0.1s ease;
            }
            
            .mobile-btn:active {
                transform: translateY(0) scale(0.96);
                transition: transform 0.1s ease;
            }
        }
        
        /* Schermi ad alta densità (Retina, ecc.) */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .gameover-text {
                text-shadow: 
                    0 0 30px rgba(255, 87, 34, 0.8),
                    0 0 10px rgba(0, 0, 0, 0.9),
                    1px 1px 2px rgba(0, 0, 0, 0.9);
            }
            
            .stat-card,
            .record-card {
                border-width: 1px;
            }
        }
        
        /* Riduzione movimento per utenti sensibili */
        @media (prefers-reduced-motion: reduce) {
            .falling-block {
                animation: none;
                opacity: 0.1;
                position: static;
            }
            
            .gameover-text {
                animation: none;
            }
            
            .record-card.new-record {
                animation: none;
            }
            
            .gameover-content::before {
                animation: none;
            }
        }
        
        /* Schermi ad alta densità (Retina, ecc.) */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .gameover-text {
                text-shadow: 
                    0 0 30px rgba(255, 87, 34, 0.8),
                    0 0 10px rgba(0, 0, 0, 0.9),
                    1px 1px 2px rgba(0, 0, 0, 0.9);
            }
            
            .stat-card,
            .record-card {
                border-width: 1px;
            }
        }
        
        /* Riduzione movimento per utenti sensibili */
        @media (prefers-reduced-motion: reduce) {
            .falling-block {
                animation: none;
                opacity: 0.1;
                position: static;
            }
            
            .gameover-text {
                animation: none;
            }
            
            .record-card.new-record {
                animation: none;
            }
            
            .gameover-content::before {
                animation: none;
            }
        }
        
        /* ==================== MIGLIORAMENTI MOBILE ==================== */
        
        /* Migliora la visibilità dei testi su mobile */
        @media (max-width: 768px) {
            .mobile-instruction {
                background: rgba(0, 0, 0, 0.9);
                padding: 0.8rem;
                border-radius: 12px;
                border: 2px solid rgba(100, 255, 218, 0.4);
                margin-top: 0.5rem;
                backdrop-filter: blur(10px);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            }
            
            .mobile-instruction::after {
                content: ' • Swipe ↑ riavvia • Swipe ↓ menu • Doppio tap riavvia';
                display: block;
                font-size: 0.8rem;
                color: #64ffda;
                margin-top: 0.5rem;
                opacity: 0.9;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            }
            
            /* Migliora contrasto sui dispositivi mobili */
            .gameover-content {
                background: rgba(15, 15, 35, 0.99);
                box-shadow: 
                    0 25px 50px rgba(0, 0, 0, 0.8),
                    inset 0 1px 0 rgba(255, 255, 255, 0.15),
                    0 0 0 2px rgba(0, 0, 0, 0.9);
            }
            
            .stat-card {
                background: rgba(0, 0, 0, 0.9);
                border-color: rgba(100, 255, 218, 0.5);
            }
            
            .record-card {
                background: rgba(0, 0, 0, 0.95);
                border-color: rgba(255, 193, 7, 0.6);
            }
        }
        
        /* Schermi molto piccoli (smartwatch, mini smartphone) */
        @media (max-width: 280px) {
            .gameover-overlay {
                padding: 0.2rem;
            }
            
            .gameover-content {
                padding: 0.8rem;
                width: 99%;
                border-radius: 15px;
            }
            
            .gameover-title {
                font-size: 1.2rem;
                gap: 0.1rem;
                margin-bottom: 0.4rem;
            }
            
            .gameover-subtitle {
                font-size: 0.8rem;
                margin-bottom: 0.8rem;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
                gap: 0.4rem;
            }
            
            .stat-card {
                padding: 0.5rem;
                border-radius: 8px;
                display: flex;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
            }
            
            .stat-icon {
                font-size: 1rem;
                margin-bottom: 0;
            }
            
            .stat-content {
                display: flex;
                flex-direction: column;
                flex: 1;
                margin-left: 0.5rem;
                text-align: left;
            }
            
            .stat-label {
                font-size: 0.7rem;
                margin-bottom: 0.2rem;
            }
            
            .stat-number {
                font-size: 0.9rem;
            }
            
            .record-card {
                padding: 0.6rem;
                border-radius: 12px;
            }
            
            .record-icon {
                font-size: 1.2rem;
            }
            
            .record-value {
                font-size: 1rem;
            }
            
            .gameover-message {
                font-size: 0.8rem;
                margin-bottom: 1rem;
            }
            
            .gameover-btn {
                font-size: 0.8rem;
                padding: 0.8rem 1rem;
                border-radius: 15px;
            }
            
            .falling-block {
                width: 4px;
                height: 4px;
                opacity: 0.1;
            }
        }
        
        /* ==================== IPAD LANDSCAPE ORIENTATIONS ==================== */
        
        /* iPad Mini/Standard Landscape (1024x768) */
        @media (min-width: 1024px) and (max-width: 1024px) and (orientation: landscape) {
            .gameover-content {
                max-width: 900px;
                width: 85%;
                padding: 1.8rem;
                max-height: 85vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(2.2rem, 4vw, 2.8rem);
                margin-bottom: 1rem;
            }
            
            .gameover-subtitle {
                font-size: 1.1rem;
                margin-bottom: 1.5rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 1rem;
            }
            
            .stat-card {
                padding: 1rem;
            }
            
            .stat-icon {
                font-size: 1.2rem;
            }
            
            .stat-number {
                font-size: 1.2rem;
            }
            
            .gameover-actions {
                flex-direction: row;
                gap: 1.5rem;
                justify-content: center;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 220px;
                font-size: 1rem;
                padding: 1.1rem 1.8rem;
            }
            
            .record-card {
                padding: 1.2rem;
                flex-direction: row;
            }
            
            .gameover-message {
                font-size: 1.1rem;
                margin-bottom: 1.5rem;
            }
        }
        
        /* iPad Air/Pro 11" Landscape (1194x834, 1180x820) */
        @media (min-width: 1025px) and (max-width: 1194px) and (orientation: landscape) {
            .gameover-content {
                max-width: 1000px;
                width: 85%;
                padding: 2rem;
                max-height: 80vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(2.5rem, 4vw, 3.2rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 1.2rem;
            }
            
            .stat-card {
                padding: 1.2rem;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 250px;
                font-size: 1.1rem;
            }
        }
        
        /* iPad Air 4/5 Landscape (1180x820) */
        @media (min-width: 1180px) and (max-width: 1180px) and (min-height: 820px) and (max-height: 820px) and (orientation: landscape) {
            .gameover-content {
                max-width: 1050px;
                width: 85%;
                padding: 2rem;
                max-height: 80vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(2.5rem, 3.5vw, 3.2rem);
                margin-bottom: 1.2rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 1.2rem;
            }
            
            .stat-card {
                padding: 1.2rem;
            }
            
            .stat-icon {
                font-size: 1.3rem;
            }
            
            .stat-number {
                font-size: 1.3rem;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 240px;
                font-size: 1.1rem;
                padding: 1.2rem 2rem;
            }
        }
        
        /* iPad Pro 11" Landscape (1194x834) */
        @media (min-width: 1194px) and (max-width: 1194px) and (min-height: 834px) and (max-height: 834px) and (orientation: landscape) {
            .gameover-content {
                max-width: 1100px;
                width: 85%;
                padding: 2.2rem;
                max-height: 80vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(2.6rem, 3.5vw, 3.4rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 1.3rem;
            }
            
            .stat-card {
                padding: 1.3rem;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 260px;
                font-size: 1.1rem;
            }
        }
        
        /* iPad Pro 12.9" Landscape (1366x1024) */
        @media (min-width: 1366px) and (max-width: 1366px) and (min-height: 1024px) and (max-height: 1024px) and (orientation: landscape) {
            .gameover-content {
                max-width: 1250px;
                width: 85%;
                padding: 2.5rem;
                max-height: 85vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(2.8rem, 3vw, 3.6rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 1.5rem;
            }
            
            .stat-card {
                padding: 1.5rem;
            }
            
            .stat-icon {
                font-size: 1.5rem;
            }
            
            .stat-number {
                font-size: 1.5rem;
            }
            
            .gameover-actions {
                flex-direction: row;
                gap: 2rem;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 300px;
                font-size: 1.2rem;
                padding: 1.3rem 2.2rem;
            }
            
            .record-card {
                padding: 1.8rem;
            }
        }
        
        /* Surface Pro 7 Landscape (1368x912) */
        @media (min-width: 1368px) and (max-width: 1368px) and (min-height: 912px) and (max-height: 912px) and (orientation: landscape) {
            .gameover-content {
                max-width: 1200px;
                width: 85%;
                padding: 2.2rem;
                max-height: 80vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(2.5rem, 3vw, 3.2rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 1.3rem;
            }
            
            .stat-card {
                padding: 1.3rem;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 280px;
                font-size: 1.1rem;
                padding: 1.2rem 2rem;
            }
        }
        
        /* ASUS ZenBook Fold Landscape esteso (1536x1024) */
        @media (min-width: 1536px) and (max-width: 1536px) and (min-height: 1024px) and (max-height: 1024px) and (orientation: landscape) {
            .gameover-content {
                max-width: 1400px;
                width: 80%;
                padding: 2.5rem;
                max-height: 85vh;
                overflow-y: auto;
            }
            
            .gameover-title {
                font-size: clamp(2.8rem, 2.5vw, 3.5rem);
            }
            
            .stats-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 1.5rem;
            }
            
            .stat-card {
                padding: 1.5rem;
            }
            
            .stat-icon {
                font-size: 1.6rem;
            }
            
            .stat-number {
                font-size: 1.6rem;
            }
            
            .gameover-actions {
                flex-direction: row;
                gap: 2.5rem;
                justify-content: center;
            }
            
            .gameover-btn {
                flex: 1;
                max-width: 320px;
                font-size: 1.3rem;
                padding: 1.4rem 2.5rem;
            }
        }
        
        /* Animazioni per dispositivi che le supportano */
        @media (prefers-reduced-motion: reduce) {
            .gameover-overlay,
            .gameover-content,
            .gameover-subtitle,
            .gameover-stats,
            .gameover-message,
            .gameover-actions,
            .gameover-instructions {
                animation: none;
            }
            
            .falling-block {
                animation: none;
                opacity: 0.2;
            }
            
            .gameover-text {
                animation: none;
            }
            
            .record-card.new-record {
                animation: none;
            }
        }

        /* Nascondi elementi Emscripten originali */
        #emscripten_logo,
        #spinner,
        #progress,
        #controls,
        #output {
            display: none !important;
        }

        #status {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Particelle animate di sfondo -->
    <div class="bg-particles">
        <div class="particle" style="left: 10%; animation-delay: 0s;"></div>
        <div class="particle" style="left: 20%; animation-delay: 1s;"></div>
        <div class="particle" style="left: 30%; animation-delay: 2s;"></div>
        <div class="particle" style="left: 40%; animation-delay: 3s;"></div>
        <div class="particle" style="left: 50%; animation-delay: 4s;"></div>
        <div class="particle" style="left: 60%; animation-delay: 5s;"></div>
        <div class="particle" style="left: 70%; animation-delay: 2.5s;"></div>
        <div class="particle" style="left: 80%; animation-delay: 1.5s;"></div>
        <div class="particle" style="left: 90%; animation-delay: 3.5s;"></div>
    </div>

    <!-- Schermata iniziale con pulsante PLAY -->
    <div class="start-screen" id="startScreen">
        <div class="start-content">
            <h1 class="start-title">🎮 TETRIS</h1>
            <p class="start-subtitle">Il Leggendario Puzzle Game</p>
            
            <div class="preview-blocks">
                <div class="preview-block"></div>
                <div class="preview-block"></div>
                <div class="preview-block"></div>
                <div class="preview-block"></div>
                <div class="preview-block"></div>
            </div>
            
            <button class="play-button" id="playButton">
                ▶️ GIOCA ORA
            </button>
            
            <div class="start-instructions">
                <p><strong>Come si gioca:</strong></p>
                
                <!-- Istruzioni per Desktop -->
                <div class="desktop-instructions">
                    <p>🖥️ <strong>Controlli Desktop:</strong><br>
                    ⬅️➡️ Frecce per muovere • ⬆️ Ruota • ⬇️ Velocizza<br>
                    ESC per pausa • Spazio per ricominciare</p>
                </div>
                
                <!-- Istruzioni per Mobile -->
                <div class="mobile-instructions">
                    <p>📱 <strong>Controlli Touch:</strong><br>
                    👆 Tap per ruotare • 📲 Swipe ⬅️➡️ per muovere<br>
                    📲 Swipe ⬇️ per velocizzare • 
                    🔄 Tieni premuto per mettere in pausa</p>
                </div>
                
                <p class="game-goal">🎯 Completa le righe per guadagnare punti<br>
                ⚡ Più veloce vai, più punti ottieni!</p>
            </div>
        </div>
    </div>

    <!-- Mobile Pause Menu -->
    <div class="mobile-pause-menu" id="mobilePauseMenu">
        <div class="mobile-pause-content">
            <div class="mobile-pause-title">⏸️ PAUSA</div>
            <div class="mobile-pause-buttons">
                <button class="mobile-btn" id="resumeGameBtn">▶️ Riprendi</button>
                <button class="mobile-btn" id="restartGameBtn">🔄 Ricomincia</button>
            </div>
        </div>
    </div>

    <!-- Desktop Pause Menu -->
    <div class="desktop-pause-menu" id="desktopPauseMenu">
        <div class="desktop-pause-content">
            <div class="desktop-pause-title">
                ⏸️ GIOCO IN PAUSA
            </div>
            <div class="desktop-pause-subtitle">
                Pronto a continuare la sfida?
            </div>
            
            <!-- Statistiche attuali -->
            <div class="desktop-pause-stats">
                <div class="desktop-pause-stats-row">
                    <span class="desktop-pause-stats-label">Punteggio</span>
                    <span class="desktop-pause-stats-value" id="desktopPauseScore">0</span>
                </div>
                <div class="desktop-pause-stats-row">
                    <span class="desktop-pause-stats-label">Livello</span>
                    <span class="desktop-pause-stats-value" id="desktopPauseLevel">1</span>
                </div>
                <div class="desktop-pause-stats-row">
                    <span class="desktop-pause-stats-label">Linee</span>
                    <span class="desktop-pause-stats-value" id="desktopPauseLines">0</span>
                </div>
                <div class="desktop-pause-stats-row">
                    <span class="desktop-pause-stats-label">Tempo</span>
                    <span class="desktop-pause-stats-value" id="desktopPauseTime">00:00</span>
                </div>
            </div>
            
            <div class="desktop-pause-buttons">
                <button class="desktop-pause-btn" id="desktopResumeBtn">
                    ▶️ Riprendi Gioco
                </button>
                <button class="desktop-pause-btn secondary" id="desktopRestartBtn">
                    🔄 Ricomincia
                </button>
                <button class="desktop-pause-btn danger" id="desktopQuitBtn">
                    🚪 Esci
                </button>
            </div>
            
            <div style="margin-top: 1.5rem; color: #78909c; font-size: 0.9rem;">
                Premi <strong>ESC</strong> per riprendere velocemente
            </div>
        </div>
    </div>

    <!-- Nuova schermata Game Over unificata per Desktop e Mobile -->
    <div class="gameover-overlay" id="gameOverOverlay">
        <div class="gameover-background">
            <!-- Particelle animate di sfondo -->
            <div class="gameover-particles">
                <div class="falling-block" style="left: 10%; animation-delay: 0s;"></div>
                <div class="falling-block" style="left: 20%; animation-delay: 0.5s;"></div>
                <div class="falling-block" style="left: 30%; animation-delay: 1s;"></div>
                <div class="falling-block" style="left: 40%; animation-delay: 1.5s;"></div>
                <div class="falling-block" style="left: 50%; animation-delay: 2s;"></div>
                <div class="falling-block" style="left: 60%; animation-delay: 2.5s;"></div>
                <div class="falling-block" style="left: 70%; animation-delay: 3s;"></div>
                <div class="falling-block" style="left: 80%; animation-delay: 3.5s;"></div>
                <div class="falling-block" style="left: 90%; animation-delay: 4s;"></div>
            </div>
        </div>
        
        <div class="gameover-content">
            <!-- Titolo animato -->
            <div class="gameover-title">
                <span class="gameover-text">GAME</span>
                <span class="gameover-text">OVER</span>
            </div>
            
            <!-- Sottotitolo con emoji -->
            <div class="gameover-subtitle" id="gameOverSubtitle">
                🎮 Partita terminata
            </div>
            
            <!-- Statistiche finali -->
            <div class="gameover-stats">
                <div class="stats-grid">
                    <div class="stat-card primary">
                        <div class="stat-icon">🏆</div>
                        <div class="stat-label">Punteggio Finale</div>
                        <div class="stat-number" id="gameOverFinalScore">0</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-icon">⚡</div>
                        <div class="stat-label">Livello Raggiunto</div>
                        <div class="stat-number" id="gameOverFinalLevel">1</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-icon">📏</div>
                        <div class="stat-label">Linee Completate</div>
                        <div class="stat-number" id="gameOverFinalLines">0</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-icon">⏰</div>
                        <div class="stat-label">Tempo Totale</div>
                        <div class="stat-number" id="gameOverFinalTime">00:00</div>
                    </div>
                </div>
                
                <!-- Record personale -->
                <div class="record-section" id="gameOverRecordSection">
                    <div class="record-card" id="gameOverRecordCard">
                        <div class="record-icon">👑</div>
                        <div class="record-text">
                            <div class="record-label">Record Personale</div>
                            <div class="record-value" id="gameOverRecordValue">0</div>
                        </div>
                        <div class="record-badge" id="gameOverNewRecordBadge">NUOVO RECORD!</div>
                    </div>
                </div>
            </div>
            
            <!-- Messaggio motivazionale -->
            <div class="gameover-message" id="gameOverMessage">
                Ottimo lavoro! Riprova per battere il tuo record!
            </div>
            
            <!-- Pulsanti di controllo -->
            <div class="gameover-actions">
                <button class="gameover-btn primary" id="gameOverRestartBtn">
                    <span class="btn-icon">🔄</span>
                    <span class="btn-text">Gioca Ancora</span>
                </button>
                
                <button class="gameover-btn secondary" id="gameOverMenuBtn">
                    <span class="btn-icon">🏠</span>
                    <span class="btn-text">Menu Principale</span>
                </button>
            </div>
            
            <!-- Istruzioni per mobile/desktop -->
            <div class="gameover-instructions">
                <div class="desktop-instruction">Premi <kbd>INVIO</kbd> per riavviare o <kbd>ESC</kbd> per il menu</div>
                <div class="mobile-instruction">👆 Tocca "Gioca Ancora" per riavviare</div>
            </div>
        </div>
    </div>

    <!-- Mobile Game Over Overlay (mantenuto per compatibilità) -->
    <div class="mobile-gameover-overlay legacy-mobile" id="mobileGameOverOverlay">
        <div class="mobile-gameover-content">
            <div class="mobile-gameover-title">GAME OVER</div>
            <div class="mobile-gameover-score" id="mobileGameOverScore">Punteggio: 0</div>
            <div class="mobile-gameover-instruction">👆 Tap per riavviare</div>
        </div>
    </div>

    <!-- Loading overlay personalizzato -->
    <div class="loading-overlay" id="customLoading">
        <div class="tetris-loader">
            <div class="tetris-block"></div>
            <div class="tetris-block"></div>
            <div class="tetris-block"></div>
            <div class="tetris-block"></div>
        </div>
        <div class="loading-text">TETRIS</div>
        <div class="loading-progress" id="loadingProgress">Caricamento del gioco...</div>
    </div>

    <!-- Header -->
    <div class="header">
        <h1 class="title">🎮 TETRIS</h1>
        <p class="subtitle">Il Classico Puzzle Game</p>
        <div class="game-info">
            Gioca al leggendario Tetris direttamente nel browser! Versione moderna compilata in WebAssembly 
            con grafica SDL2, audio coinvolgente e controlli reattivi. Nessun download richiesto.
        </div>
    </div>

    <!-- Container del gioco -->
    <div class="game-container">
        <div class="game-wrapper">
            <!-- Layout con statistiche sui lati -->
            <div class="game-layout">
                <!-- Statistiche a sinistra -->
                <div class="left-stats">
                    <div class="stats-panel">
                        <h3 class="stats-title">📊 STATS</h3>
                        <div class="stat-item">
                            <span class="stat-label">Punteggio</span>
                            <span class="stat-value" id="scoreDisplay">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Livello</span>
                            <span class="stat-value" id="levelDisplay">1</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Linee</span>
                            <span class="stat-value" id="linesDisplay">0</span>
                        </div>
                    </div>
                </div>

                <!-- Canvas del gioco al centro -->
                <div class="game-canvas">
                    <canvas id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
                </div>

                <!-- Info aggiuntive a destra -->
                <div class="right-info">
                    <div class="info-panel">
                        <h3 class="info-title">🎮 INFO</h3>
                        <div class="info-item">
                            <span class="info-label">Stato</span>
                            <span class="info-value" id="gameState">Pronto</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Tempo</span>
                            <span class="info-value" id="gameTime">00:00</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Record</span>
                            <span class="info-value" id="highScore">0</span>
                        </div>
                    </div>
                    
                    <!-- Audio Controls / Controlli Audio -->
                    <div class="info-panel audio-controls">
                        <h3 class="info-title">🔊 AUDIO</h3>
                        
                        <div class="info-item volume-control">
                            <span class="info-label">Volume</span>
                            <div class="volume-slider-container">
                                <input type="range" id="volume-slider" class="volume-slider" 
                                       min="0" max="100" value="30" step="1">
                                <span class="volume-value" id="volume-value">30</span>
                            </div>
                        </div>
                        
                        <div class="info-item mute-control">
                            <button id="mute-button" class="mute-btn">
                                <span class="mute-icon">🔊</span>
                                <span class="mute-text">Mute</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Controlli -->
            <div class="controls desktop-only">
                <div class="control-item">
                    <div class="control-key">← →</div>
                    <div class="control-desc">Movimento</div>
                </div>
                <div class="control-item">
                    <div class="control-key">↑</div>
                    <div class="control-desc">Ruota</div>
                </div>
                <div class="control-item">
                    <div class="control-key">↓</div>
                    <div class="control-desc">Caduta veloce</div>
                </div>
                <div class="control-item">
                    <div class="control-key">ESC</div>
                    <div class="control-desc">Pausa</div>
                </div>
                <div class="control-item">
                    <div class="control-key">INVIO</div>
                    <div class="control-desc">Ricomincia</div>
                </div>
                <div class="control-item mobile-only">
                    <div class="control-key">📱</div>
                    <div class="control-desc">Touch/Swipe</div>
                </div>
            </div>
            
            <!-- Istruzioni Mobile -->
            <div class="mobile-instructions">
                <h3>📱 Controlli Touch</h3>
                <div class="touch-controls">
                    <div class="touch-item">
                        <span class="touch-gesture">👆 Tap</span>
                        <span class="touch-action">Ruota pezzo</span>
                    </div>
                    <div class="touch-item">
                        <span class="touch-gesture">👈 👉 Swipe</span>
                        <span class="touch-action">Muovi lateralmente</span>
                    </div>
                    <div class="touch-item">
                        <span class="touch-gesture">👇 Swipe giù</span>
                        <span class="touch-action">Caduta veloce</span>
                    </div>
                </div>
                
                <!-- Mobile Long Press Help Text -->
                <div class="mobile-game-controls">
                    <div class="mobile-help-text">Tieni premuto per menu pausa</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <div class="footer">
        <p>Creato con ❤️ utilizzando C++, SDL2 e WebAssembly</p>
        <p>© 2025 - <a href="https://github.com/gianfrizio/Tetris" target="_blank">Codice sorgente su GitHub</a></p>
    </div>

    <!-- Script Emscripten (modificato) -->
    <script>
    // Elementi DOM
    const startScreen = document.getElementById('startScreen');
    const playButton = document.getElementById('playButton');
    const customLoading = document.getElementById('customLoading');
    const loadingProgress = document.getElementById('loadingProgress');
    const gameContainer = document.querySelector('.game-container');

    let gameReady = false;
    let gameStarted = false;
    let gameStartRequested = false;
        
        // Nascondi il loading inizialmente
        customLoading.style.display = 'none';
        
        // Ensure Module is available on the global object for Emscripten compatibility
        globalThis.Module = globalThis.Module || {};
        Object.assign(globalThis.Module, {
            canvas: document.getElementById('canvas'),

            print: function(...args) {
                console.log(...args);
            },

            setStatus: function(text) {
                // Carica il gioco silenziosamente in background
                if (text) {
                    console.log('Game status:', text);
                    if (text.includes('complete') || !text) {
                        gameReady = true;
                        console.log('Game is ready!');
                    }
                } else {
                    gameReady = true;
                    console.log('Game ready (no status)');
                }
                
                // Se il gioco è stato avviato dall'utente, mostra i progressi
                if (gameStarted) {
                    if (text && text.includes('Downloading')) {
                        loadingProgress.textContent = 'Download del gioco...';
                    } else if (text && text.includes('Preparing')) {
                        loadingProgress.textContent = 'Preparazione...';
                    } else {
                        loadingProgress.textContent = 'Avvio del gioco...';
                    }
                }
            },
            
            totalDependencies: 0,
            monitorRunDependencies: function(left) {
                this.totalDependencies = Math.max(this.totalDependencies, left);
                console.log('Dependencies left:', left);
                if (left === 0) {
                    gameReady = true;
                }
            }
        });

        // Gestione pulsante PLAY
        playButton.addEventListener('click', function() {
            gameStarted = true;
            gameStartRequested = true;
            
            // Nascondi schermata iniziale
            startScreen.classList.add('hidden');
            
            // Mostra loading
            customLoading.style.display = 'flex';
            customLoading.style.opacity = '1';
            loadingProgress.textContent = 'Avvio del gioco...';
            
            setTimeout(() => {
                startScreen.style.display = 'none';
                
                // Aspetta che il gioco sia caricato, poi avvialo
                setTimeout(() => {
                    customLoading.style.opacity = '0';
                    setTimeout(() => {
                        customLoading.style.display = 'none';
                        gameContainer.classList.add('visible');
                        
                        // Fit canvas to viewport
                        fitCanvasToViewport();
                        
                        // Avvia il gioco chiamando la funzione C++
                        let gameStarted = false;
                        
                        function tryStartGame() {
                            if (gameStarted) return; // Evita di avviare il gioco più volte
                            
                            try {
                                if (typeof Module !== 'undefined' && Module._startTetrisGame) {
                                    Module._startTetrisGame();
                                    gameStarted = true;
                                    console.log('Game started via C++ function!');
                                    
                                    // Avvia il timer JavaScript
                                    window.startGameTimer();
                                    
                                    // Avvia l'aggiornamento delle statistiche
                                    startStatsUpdater();
                                } else {
                                    console.log('Module not ready yet, retrying...');
                                    // Riprova una sola volta dopo un po'
                                    setTimeout(() => {
                                        if (!gameStarted && typeof Module !== 'undefined' && Module._startTetrisGame) {
                                            Module._startTetrisGame();
                                            gameStarted = true;
                                            console.log('Game started via C++ function (retry)!');
                                            
                                            // Avvia il timer JavaScript
                                            window.startGameTimer();
                                            
                                            // Avvia l'aggiornamento delle statistiche
                                            startStatsUpdater();
                                        }
                                    }, 500);
                                }
                            } catch(e) {
                                console.error('Error starting game:', e);
                            }
                        }
                        
                        tryStartGame();
                    }, 500);
                }, 1000);
            }, 800);
        });

        // Gestione errori personalizzata
        window.onerror = function(event) {
            if (gameStarted) {
                loadingProgress.textContent = 'Errore nel caricamento del gioco';
                console.error('Game loading error:', event);
            }
        };
        
        // Ferma l'aggiornamento statistiche quando la pagina viene chiusa
        window.addEventListener('beforeunload', function() {
            stopStatsUpdater();
        });
        
        // Effetto di transizione per il loading
        customLoading.style.transition = 'opacity 0.5s ease-in-out';
        
        // Sistema di aggiornamento statistiche del gioco
        let statsUpdateInterval;
        let lastScore = 0;
        let lastLevel = 1;
        let lastLines = 0;
        let gameStartTimeReal = null;
        let highScore = localStorage.getItem('tetris-high-score') || 0;
        let isGameOver = false;
        let gameEndTime = null;
        let lastRunningState = true;
        let gameStoppedTime = null;
        let lastScoreCheck = 0;
        let scoreStuckCount = 0;
        let totalPausedTime = 0;
        let pauseStartTime = null;
        let lastGameRunningState = true;
        let isManuallyPaused = false;
        let isTimerRunning = true;
        let lastScoreChangeTime = Date.now();
        
        function startStatsUpdater() {
            console.log('Starting stats updater...');
            
        // Reset dello stato del gioco
        isGameOver = false;
        gameEndTime = null;
        lastRunningState = true;
        gameStoppedTime = null;
        lastScoreCheck = 0;
        scoreStuckCount = 0;
        totalPausedTime = 0;
        pauseStartTime = null;
        lastGameRunningState = true;
        isManuallyPaused = false;
        isTimerRunning = true;
        lastScoreChangeTime = Date.now();
        
        console.log('🔄 Game state reset for new game');            // Inizializza il tempo di gioco
            gameStartTimeReal = Date.now();
            
            // Imposta il record salvato
            document.getElementById('highScore').textContent = parseInt(highScore).toLocaleString();
            
            // La musica è gestita dal codice C++ del gioco
            
            // Aggiorna le statistiche ogni 100ms
            statsUpdateInterval = setInterval(updateGameStats, 100);
        }
        
        function updateGameStats() {
            try {
                // PRIMA: Aggiorna il tempo di gioco (SENZA SINCRONIZZAZIONE C++ CHE ROMPE)
                updateGameTime();
                
                // TERZA: Aggiorna le statistiche del C++
                if (typeof Module !== 'undefined') {
                    try {
                        const score = Module._getScore();
                        const level = Module._getLevel();
                        const lines = Module._getLines();
                        
                        // Aggiorna il punteggio solo se cambiato
                        if (score !== lastScore) {
                            lastScore = score;
                            lastScoreChangeTime = Date.now();
                            
                            // Aggiorna record se necessario
                            if (score > highScore) {
                                highScore = score;
                                localStorage.setItem('tetris-high-score', highScore);
                            }
                        }
                        
                        // Aggiorna tutti i display
                        const scoreElement = document.getElementById('scoreDisplay');
                        const levelElement = document.getElementById('levelDisplay');
                        const linesElement = document.getElementById('linesDisplay');
                        const highScoreElement = document.getElementById('highScore');
                        
                        if (scoreElement) scoreElement.textContent = score.toLocaleString();
                        if (levelElement) levelElement.textContent = level;
                        if (linesElement) linesElement.textContent = lines;
                        if (highScoreElement) highScoreElement.textContent = parseInt(highScore).toLocaleString();
                        
                    } catch (error) {
                        // Ignora errori di accesso al Module
                    }
                }
                
                // QUARTA: Sincronizza con lo stato del C++
                syncGameStateWithCpp();
                
                // QUINTA: Aggiorna il display dello stato
                updateGameState();
                
            } catch(e) {
                console.error('Error updating stats:', e);
            }
        }
        
        // Nuova funzione per sincronizzare lo stato JavaScript con il C++
        function syncWithCppState() {
            if (typeof Module === 'undefined') return;
            
            try {
                const cppRunning = Module._isGameRunning ? Module._isGameRunning() : false;
                const cppPaused = Module._isGamePaused ? Module._isGamePaused() : false;
                
                // Se il C++ dice che il gioco è in pausa ma JavaScript no
                if (cppPaused && !isPaused && !isGameOver) {
                    console.log('🎮 C++ is paused, syncing JavaScript');
                    isPaused = true;
                    isTimerRunning = false;
                    if (!pauseStartTime) {
                        pauseStartTime = Date.now();
                    }
                    
                    const gameStateElement = document.getElementById('gameState');
                    if (gameStateElement) {
                        gameStateElement.textContent = 'In pausa';
                        gameStateElement.style.color = '#ffa726';
                    }
                }
                // Se il C++ dice che il gioco non è in pausa ma JavaScript sì
                else if (!cppPaused && isPaused && cppRunning) {
                    console.log('🎮 C++ resumed, syncing JavaScript');
                    if (pauseStartTime) {
                        totalPausedTime += Date.now() - pauseStartTime;
                        pauseStartTime = null;
                    }
                    isPaused = false;
                    isTimerRunning = true;
                    
                    const gameStateElement = document.getElementById('gameState');
                    if (gameStateElement) {
                        gameStateElement.textContent = 'In corso';
                        gameStateElement.style.color = '';
                    }
                }
                // Se il C++ non è running e non è paused, probabilmente è game over
                else if (!cppRunning && !cppPaused && gameStartTimeReal && !isGameOver) {
                    console.log('🎮 C++ game over detected, syncing JavaScript');
                    isGameOver = true;
                    isTimerRunning = false;
                    isPaused = false;
                    gameEndTime = Date.now();
                    
                    const gameStateElement = document.getElementById('gameState');
                    if (gameStateElement) {
                        gameStateElement.textContent = 'Game Over';
                        gameStateElement.style.color = '#ff5722';
                    }
                }
                
            } catch(e) {
                // Ignora errori di sincronizzazione
            }
        }
        
        function checkForGameOver() {
            if (isGameOver || !isTimerRunning) return; // Se già in game over o in pausa, non controllare
            
            // Metodo 1: Rileva se il punteggio non cambia per molto tempo e il gioco sembra fermo
            const currentTime = Date.now();
            
            // Se il punteggio è cambiato, aggiorna il timestamp
            if (lastScore !== lastScoreCheck) {
                lastScoreChangeTime = currentTime;
                lastScoreCheck = lastScore;
                scoreStuckCount = 0;
                return;
            }
            
            // Se il punteggio è > 0 e non cambia da più di 3 secondi, è game over
            if (lastScore > 0 && (currentTime - lastScoreChangeTime) > 3000) {
                console.log('� GAME OVER AUTO-DETECTED! Score stuck for 3+ seconds with score:', lastScore);
                stopTimer();
                return;
            }
            
            // Metodo alternativo: conta i cicli di controllo
            scoreStuckCount++;
            if (lastScore > 0 && scoreStuckCount > 30) { // 30 * 100ms = 3 secondi
                console.log('💀 GAME OVER AUTO-DETECTED! Score stuck counter reached:', scoreStuckCount);
                stopTimer();
            }
            
            // Metodo 2: Rileva pattern di game over tramite eventi DOM o canvas
            // Questo potrebbe essere migliorato osservando il canvas per messaggi di game over
            try {
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    // Qui potremmo analizzare il contenuto del canvas per cercare testo "GAME OVER"
                    // Per ora usiamo solo il metodo del punteggio bloccato
                }
            } catch(e) {
                // Ignora errori di analisi canvas
            }
        }
        
        function updateGameTime() {
            const gameTimeElement = document.getElementById('gameTime');
            
            if (!gameTimeElement || !gameStartTimeReal) return;
            
            let elapsed, minutes, seconds, timeString;
            
            if (isGameOver) {
                // Game over - usa tempo fisso
                if (gameEndTime) {
                    elapsed = Math.floor((gameEndTime - gameStartTimeReal - totalPausedTime) / 1000);
                } else {
                    elapsed = Math.floor((Date.now() - gameStartTimeReal - totalPausedTime) / 1000);
                }
                minutes = Math.floor(elapsed / 60);
                seconds = elapsed % 60;
                timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                gameTimeElement.textContent = timeString + ' (FINAL)';
                gameTimeElement.style.color = '#ff5722';
                return;
            }
            
            if (isTimerRunning) {
                // Timer attivo - calcola tempo corrente
                const currentTime = isPaused ? pauseStartTime : Date.now();
                elapsed = Math.floor((currentTime - gameStartTimeReal - totalPausedTime) / 1000);
                minutes = Math.floor(elapsed / 60);
                seconds = elapsed % 60;
                timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (isPaused) {
                    gameTimeElement.textContent = timeString + ' (PAUSA)';
                    gameTimeElement.style.color = '#ffa726';
                } else {
                    gameTimeElement.textContent = timeString;
                    gameTimeElement.style.color = '';
                }
            }
        }
        
        // Funzione separata per sincronizzare lo stato JavaScript con il C++
        function syncGameStateWithCpp() {
            try {
                // Se c'è un menu mobile attivo o long press in corso, NON sincronizzare
                const mobilePauseMenu = document.getElementById('mobilePauseMenu');
                if ((mobilePauseMenu && mobilePauseMenu.classList.contains('active')) || longPressTriggered || mobilePauseActive) {
                    console.log('🚫 Sync disabilitata - sistema mobile pause attivo');
                    return;
                }
                
                if (typeof Module !== 'undefined' && Module._isGameRunning && Module._isGamePaused) {
                    const cppRunning = Module._isGameRunning();
                    const cppPaused = Module._isGamePaused();
                    
                    // Rileva game over: non running e non paused
                    if (!cppRunning && !cppPaused && !isGameOver && gameStartTimeReal) {
                        console.log('🎮 GAME OVER detected - syncing state');
                        isGameOver = true;
                        isTimerRunning = false;
                        isPaused = false;
                        if (!gameEndTime) {
                            gameEndTime = Date.now();
                            
                            // Se eravamo in pausa, calcola il tempo di pausa finale
                            if (pauseStartTime) {
                                totalPausedTime += gameEndTime - pauseStartTime;
                                pauseStartTime = null;
                            }
                            
                            console.log('⏰ Timer stopped at game over:', new Date(gameEndTime).toLocaleTimeString());
                            
                            // Mostra la nuova schermata game over se non è già attiva
                            if (!newGameOverActive) {
                                // Ottieni le statistiche finali
                                let finalScore = lastScore;
                                let finalLevel = lastLevel || 1;
                                let finalLines = lastLines || 0;
                                
                                try {
                                    if (typeof Module !== 'undefined') {
                                        if (Module._getScore) finalScore = Module._getScore();
                                        if (Module._getLevel) finalLevel = Module._getLevel();
                                        if (Module._getLines) finalLines = Module._getLines();
                                    }
                                } catch(e) {
                                    console.log('Error getting stats for game over sync:', e);
                                }
                                
                                const gameTime = document.getElementById('gameTime')?.textContent?.replace(' (FINAL)', '').replace(' (PAUSA)', '') || '00:00';
                                
                                console.log('🎮 Triggering game over from state sync');
                                setTimeout(() => {
                                    showNewGameOver(finalScore, finalLevel, finalLines, gameTime);
                                }, 500); // Small delay to ensure all state is settled
                            }
                        }
                    }
                    // Rileva pausa
                    else if (cppPaused && !isPaused && !isGameOver) {
                        console.log('🎮 PAUSE detected - syncing state');
                        isPaused = true;
                        isTimerRunning = false;
                        if (!pauseStartTime) {
                            pauseStartTime = Date.now();
                        }
                    }
                    // Rileva resume
                    else if (!cppPaused && isPaused && cppRunning) {
                        console.log('🎮 RESUME detected - syncing state');
                        if (pauseStartTime) {
                            totalPausedTime += Date.now() - pauseStartTime;
                            pauseStartTime = null;
                        }
                        isPaused = false;
                        isTimerRunning = true;
                    }
                    // Rileva RESTART dopo game over: game running ma era game over
                    else if (cppRunning && !cppPaused && isGameOver) {
                        console.log('🎮 RESTART after game over detected - resetting all info');
                        resetGameInfo(); // Reset completo delle informazioni
                    }
                }
            } catch(e) {
                // Ignora errori di sincronizzazione
            }
        }
        
        // Funzione semplice per aggiornare solo il display dello stato
        function updateGameState() {
            const gameStateElement = document.getElementById('gameState');
            if (!gameStateElement) return;
            
            // Aggiorna solo il display dello stato
            if (isGameOver) {
                gameStateElement.textContent = 'Game Over';
                gameStateElement.style.color = '#ff5722';
                gameStateElement.style.textShadow = '0 0 10px #ff5722';
            } else if (isPaused || !isTimerRunning) {
                gameStateElement.textContent = 'Pausa';
                gameStateElement.style.color = '#ffb74d';
                gameStateElement.style.textShadow = '0 0 8px #ffb74d';
            } else {
                gameStateElement.textContent = 'In corso';
                gameStateElement.style.color = '';
                gameStateElement.style.textShadow = '';
            }
        }
        
        function handleGameOver() {
            console.log('🎮 GAME OVER DETECTED! Stopping timer.');
            
            // Ferma il timer
            if (!gameEndTime) {
                isTimerRunning = false;
                gameEndTime = Date.now();
                
                // Se eravamo in pausa quando il gioco è finito, aggiungi l'ultima pausa
                if (pauseStartTime) {
                    const finalPauseDuration = gameEndTime - pauseStartTime;
                    totalPausedTime += finalPauseDuration;
                    pauseStartTime = null;
                }
                
                console.log('⏰ Timer stopped at:', new Date(gameEndTime).toLocaleTimeString());
                console.log('📊 Total paused time:', Math.floor(totalPausedTime / 1000), 'seconds');
            }
            
            // Ottieni le statistiche finali e mostra la nuova schermata game over
            let finalScore = lastScore;
            let finalLevel = lastLevel || 1;
            let finalLines = lastLines || 0;
            let finalTime = '00:00';
            
            try {
                if (typeof Module !== 'undefined') {
                    if (Module._getScore) finalScore = Module._getScore();
                    if (Module._getLevel) finalLevel = Module._getLevel();
                    if (Module._getLines) finalLines = Module._getLines();
                }
                
                // Ottieni il tempo finale dal display
                const gameTimeElement = document.getElementById('gameTime');
                if (gameTimeElement) {
                    finalTime = gameTimeElement.textContent.replace(' (FINAL)', '').replace(' (PAUSA)', '');
                }
            } catch(e) {
                console.log('Error getting final game stats:', e);
            }
            
            // Mostra la nuova schermata game over unificata
            console.log('🎮 Showing unified game over screen with stats:', { finalScore, finalLevel, finalLines, finalTime });
            showNewGameOver(finalScore, finalLevel, finalLines, finalTime);
            
            // Aggiorna il record se necessario (questo è ora gestito in showNewGameOver)
            if (finalScore > highScore) {
                highScore = finalScore;
                localStorage.setItem('tetris-high-score', highScore);
                console.log('🏆 New high score:', highScore);
                
                // Mostra notifica nuovo record nel pannello laterale
                const highScoreElement = document.getElementById('highScore');
                if (highScoreElement) {
                    highScoreElement.style.color = '#ff9800';
                    highScoreElement.style.textShadow = '0 0 15px #ff9800';
                    highScoreElement.textContent = parseInt(highScore).toLocaleString();
                }
            }
        }
        
        // Funzione per testare manualmente il game over
        window.triggerGameOver = function() {
            console.log('🧪 Manual game over trigger');
            isGameOver = true;
            handleGameOver();
        };
        
        // Le funzioni audio sono gestite dal codice C++ del gioco
        
        // Funzioni per controllare manualmente il timer
        function pauseTimer() {
            if (isTimerRunning && !isGameOver) {
                isPaused = true;
                pauseStartTime = Date.now();
                console.log('⏸️ Timer paused');
                
                // Aggiorna il display
                const gameStateElement = document.getElementById('gameState');
                if (gameStateElement) {
                    gameStateElement.textContent = 'In pausa';
                    gameStateElement.style.color = '#ffa726';
                }
            }
        }
        
        function resumeTimer() {
            if (isPaused && !isGameOver) {
                if (pauseStartTime) {
                    const pauseDuration = Date.now() - pauseStartTime;
                    totalPausedTime += pauseDuration;
                    console.log('▶️ Timer resumed, pause duration:', Math.floor(pauseDuration / 1000), 'seconds');
                }
                isPaused = false;
                pauseStartTime = null;
                
                // Aggiorna il display
                const gameStateElement = document.getElementById('gameState');
                if (gameStateElement) {
                    gameStateElement.textContent = 'In corso';
                    gameStateElement.style.color = '';
                }
            }
        }
        
        function stopTimer() {
            console.log('🛑 Stopping timer (game over)');
            
            isGameOver = true;
            isTimerRunning = false;
            gameEndTime = Date.now();
            
            if (pauseStartTime) {
                pauseStartTime = null;
            }
            
            handleGameOver();
        }
        
        // Funzioni esposte per test manuali
        window.pauseTimer = pauseTimer;
        window.resumeTimer = resumeTimer;
        window.stopTimer = stopTimer;
        window.restartTimer = restartTimer;
        
        // Funzioni FORZATE che funzionano sempre
        function forceCompleteRestart() {
            console.log('� SAFE COMPLETE RESTART - Timer + Game');
            
            // STEP 1: RESETTA TUTTO JavaScript
            gameStartTimeReal = Date.now();
            isTimerRunning = true;
            isGameOver = false;
            isPaused = false;
            totalPausedTime = 0;
            pauseStartTime = null;
            gameEndTime = null;
            lastScore = 0;
            
            // RESET GAME OVER STATE - CRUCIALE!
            newGameOverActive = false;
            mobileGameOverActive = false;
            lastKnownScore = 0;
            lastScoreChangeTime = Date.now();
            
            // STEP 2: AGGIORNA DISPLAY SUBITO
            const gameTimeElement = document.getElementById('gameTime');
            const gameStateElement = document.getElementById('gameState');
            
            if (gameTimeElement) {
                gameTimeElement.style.color = '';
                gameTimeElement.textContent = '00:00';
            }
            
            if (gameStateElement) {
                gameStateElement.style.color = '';
                gameStateElement.textContent = 'In corso';
            }
            
            // STEP 3: RIAVVIA IL GIOCO C++ IN MODO SICURO
            console.log('🎮 Trying safe C++ restart...');
            
            try {
                if (typeof Module !== 'undefined') {
                    // Prova prima _restartTetrisGame
                    if (Module._restartTetrisGame) {
                        console.log('Calling _restartTetrisGame...');
                        Module._restartTetrisGame();
                        console.log('✅ _restartTetrisGame called successfully');
                    }
                    // Se non esiste, prova _startTetrisGame
                    else if (Module._startTetrisGame) {
                        console.log('Calling _startTetrisGame...');
                        Module._startTetrisGame();
                        console.log('✅ _startTetrisGame called successfully');
                    }
                    // Ultimo tentativo: usa ccall se disponibile
                    else if (Module.ccall) {
                        try {
                            console.log('Trying ccall method...');
                            Module.ccall('restartTetrisGame', null, []);
                            console.log('✅ ccall restart succeeded');
                        } catch(e) {
                            try {
                                Module.ccall('startTetrisGame', null, []);
                                console.log('✅ ccall start succeeded');
                            } catch(e2) {
                                console.log('❌ ccall methods failed');
                            }
                        }
                    }
                    else {
                        console.log('❌ No C++ restart methods available');
                        console.log('Available Module functions:');
                        window.listModuleFunctions();
                    }
                } else {
                    console.log('❌ Module not available');
                }
            } catch(e) {
                console.error('❌ C++ restart failed:', e);
            }
            
            console.log('✅ RESTART COMPLETED - Timer is running, C++ hopefully restarted');
        }
        
        function forcePause(reason = 'manual') {
            console.log('💥 FORCING PAUSE (' + reason + ')');
            
            if (!isPaused && !isGameOver) {
                isPaused = true;
                isTimerRunning = false;  // FERMA IL TIMER SUBITO
                pauseStartTime = Date.now();
                
                // AGGIORNA DISPLAY SUBITO
                const gameStateElement = document.getElementById('gameState');
                if (gameStateElement) {
                    if (reason === 'background' || reason === 'auto') {
                        gameStateElement.textContent = 'Auto-pausa';
                        gameStateElement.style.color = '#ff9800';
                    } else {
                        gameStateElement.textContent = 'In pausa';
                        gameStateElement.style.color = '#ffa726';
                    }
                }
                
                console.log('✅ PAUSE FORCED - Timer stopped (' + reason + ')');
            }
        }
        
        function forceResume(reason = 'manual') {
            console.log('💥 FORCING RESUME (' + reason + ')');
            
            if (isPaused && !isGameOver) {
                if (pauseStartTime) {
                    const pauseDuration = Date.now() - pauseStartTime;
                    totalPausedTime += pauseDuration;
                    console.log('⏱️ Added pause duration:', pauseDuration, 'ms');
                }
                
                isPaused = false;
                isTimerRunning = true;  // RIPRENDI IL TIMER SUBITO
                pauseStartTime = null;
                
                // Reset auto-pause state when resuming
                if (reason === 'auto' || reason === 'background') {
                    wasAutoPaused = false;
                    autoPauseReason = '';
                }
                
                // AGGIORNA DISPLAY SUBITO
                const gameStateElement = document.getElementById('gameState');
                if (gameStateElement) {
                    gameStateElement.textContent = 'In corso';
                    gameStateElement.style.color = '';
                }
                
                console.log('✅ RESUME FORCED - Timer running (' + reason + ')');
            }
        }
        
        // Funzioni aggiuntive per controllo manuale
        window.startGameTimer = function() {
            console.log('🎮 Starting game timer manually');
            gameStartTimeReal = Date.now();
            isTimerRunning = true;
            isGameOver = false;
            isPaused = false;
            totalPausedTime = 0;
            pauseStartTime = null;
            gameEndTime = null;
            
            const gameStateElement = document.getElementById('gameState');
            if (gameStateElement) {
                gameStateElement.textContent = 'In corso';
                gameStateElement.style.color = '';
            }
        };
        
        window.stopGameTimer = function() {
            console.log('🎮 Stopping game timer manually');
            isGameOver = true;
            isTimerRunning = false;
            gameEndTime = Date.now();
            
            const gameStateElement = document.getElementById('gameState');
            if (gameStateElement) {
                gameStateElement.textContent = 'Game Over';
                gameStateElement.style.color = '#ff5722';
            }
        };
        
        window.forceCompleteRestart = forceCompleteRestart;
        window.forcePause = forcePause;
        window.forceResume = forceResume;
        
        // Debug function to see available Module functions
        window.listModuleFunctions = function() {
            if (typeof Module !== 'undefined') {
                console.log('Available Module functions:');
                for (let key in Module) {
                    if (typeof Module[key] === 'function' && key.startsWith('_')) {
                        console.log('  ' + key);
                    }
                }
            } else {
                console.log('Module not available yet');
            }
        };
        
        // Debug function to check game state
        window.checkGameState = function() {
            console.log('=== GAME STATE DEBUG ===');
            console.log('JavaScript state:');
            console.log('  isTimerRunning:', isTimerRunning);
            console.log('  isPaused:', isPaused);
            console.log('  isGameOver:', isGameOver);
            console.log('  gameStartTimeReal:', gameStartTimeReal);
            console.log('  wasAutoPaused:', wasAutoPaused);
            console.log('  autoPauseReason:', autoPauseReason);
            console.log('  document.hidden:', document.hidden);
            console.log('  document.visibilityState:', document.visibilityState);
            
            if (typeof Module !== 'undefined') {
                console.log('C++ state:');
                try {
                    if (Module._isGameRunning) console.log('  isGameRunning:', Module._isGameRunning());
                    if (Module._isGamePaused) console.log('  isGamePaused:', Module._isGamePaused());
                    if (Module._getScore) console.log('  score:', Module._getScore());
                } catch(e) {
                    console.log('  Error reading C++ state:', e);
                }
            } else {
                console.log('C++ Module not available');
            }
            console.log('========================');
        };
        
        // Debug functions for testing auto-pause
        window.testAutoPause = function() {
            console.log('🧪 Testing auto-pause...');
            if (!isPaused && !isGameOver && gameStartRequested) {
                wasAutoPaused = true;
                autoPauseReason = 'test';
                forcePause('test');
                console.log('✅ Auto-pause test activated - game should be paused');
            } else {
                console.log('❌ Cannot test auto-pause - game not running or already paused');
            }
        };
        
        // ==================== DEBUG FUNCTIONS PER GAME OVER ====================
        
        window.testGameOver = function(score = 1234, level = 5, lines = 23) {
            console.log('🧪 Testing new game over screen with score:', score);
            const gameTime = document.getElementById('gameTime')?.textContent || '02:34';
            showNewGameOver(score, level, lines, gameTime);
        };
        
        window.testNewRecordGameOver = function() {
            console.log('🧪 Testing new record game over screen');
            const currentRecord = parseInt(localStorage.getItem('tetris-high-score') || '0');
            const newScore = currentRecord + 1000;
            showNewGameOver(newScore, 8, 45, '05:23');
        };
        
        window.testLowScoreGameOver = function() {
            console.log('🧪 Testing low score game over screen');
            showNewGameOver(150, 2, 3, '01:12');
        };
        
        window.hideGameOverTest = function() {
            console.log('🧪 Hiding game over screen');
            hideNewGameOver();
        };
        
        window.resetHighScore = function() {
            localStorage.removeItem('tetris-high-score');
            console.log('🗑️ High score reset');
        };
        
        window.checkGameOverState = function() {
            console.log('🔍 Checking game over state:');
            console.log('  newGameOverActive:', newGameOverActive);
            console.log('  mobileGameOverActive:', mobileGameOverActive);
            console.log('  isGameOver:', isGameOver); 
            console.log('  lastKnownScore:', lastKnownScore);
            console.log('  Game over overlay classes:', document.getElementById('gameOverOverlay')?.className);
            
            if (typeof Module !== 'undefined') {
                try {
                    console.log('  C++ game running:', Module._isGameRunning ? Module._isGameRunning() : 'unknown');
                    console.log('  C++ current score:', Module._getScore ? Module._getScore() : 'unknown');
                } catch(e) {
                    console.log('  C++ state: error reading');
                }
            }
        };
        
        window.forceResetGameOverState = function() {
            console.log('🔧 Force resetting game over state');
            newGameOverActive = false;
            mobileGameOverActive = false;
            lastKnownScore = 0;
            
            const overlay = document.getElementById('gameOverOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                overlay.style.display = 'none';
            }
            
            console.log('✅ Game over state force reset complete');
        };
        
        window.restartGameOverMonitoring = function() {
            console.log('🔄 Restarting game over monitoring system');
            
            // Stop existing monitoring
            if (gameOverCheckInterval) {
                clearInterval(gameOverCheckInterval);
                gameOverCheckInterval = null;
            }
            
            // Reset flags
            gameOverMonitoringInitialized = false;
            lastKnownScore = 0;
            
            // Restart monitoring
            startGameOverMonitoring();
            
            console.log('✅ Game over monitoring restarted');
        };
        
        window.testGameOverSequence = function() {
            console.log('🧪 Testing complete game over sequence');
            
            // Step 1: Simulate game over
            console.log('1. Showing game over...');
            testGameOver(1500, 4, 12);
            
            setTimeout(() => {
                console.log('2. Simulating restart click...');
                restartFromGameOver();
                
                setTimeout(() => {
                    console.log('3. Testing second game over...');
                    testGameOver(2500, 6, 18);
                    
                    console.log('✅ Test sequence complete - check if both game overs showed');
                }, 2000);
            }, 3000);
        };
        
        window.testAutoResume = function() {
            console.log('🧪 Testing auto-resume...');
            if (wasAutoPaused) {
                showResumeDialog();
                console.log('✅ Resume dialog should appear');
            } else {
                console.log('❌ Cannot test auto-resume - game was not auto-paused');
            }
        };
        
        // Debug helper to simulate background/foreground
        window.simulateBackground = function() {
            console.log('🧪 Simulating background...');
            // Manually trigger the visibility change handler
            Object.defineProperty(document, 'hidden', { value: true, configurable: true });
            document.dispatchEvent(new Event('visibilitychange'));
        };
        
        window.simulateForeground = function() {
            console.log('🧪 Simulating foreground...');
            Object.defineProperty(document, 'hidden', { value: false, configurable: true });
            document.dispatchEvent(new Event('visibilitychange'));
        };
        
        // Debug functions for desktop pause menu
        window.showDesktopMenu = function() {
            console.log('🧪 Showing desktop pause menu...');
            showDesktopPauseMenu();
        };
        
        window.hideDesktopMenu = function() {
            console.log('🧪 Hiding desktop pause menu...');
            hideDesktopPauseMenu();
        };
        
        // Function to check if JS and C++ states are synchronized
        window.checkSyncState = function() {
            if (typeof Module === 'undefined') {
                console.log('❌ Module not available - cannot check sync');
                return false;
            }
            
            try {
                const cppRunning = Module._isGameRunning ? Module._isGameRunning() : true;
                const cppPaused = Module._isGamePaused ? Module._isGamePaused() : false;
                
                console.log('=== SYNC STATE CHECK ===');
                console.log('JavaScript state:');
                console.log('  isPaused:', isPaused);
                console.log('  isGameOver:', isGameOver);
                console.log('  isTimerRunning:', isTimerRunning);
                console.log('C++ state:');
                console.log('  isGameRunning:', cppRunning);
                console.log('  isGamePaused:', cppPaused);
                
                const jsExpectsPaused = isPaused || isGameOver;
                const cppIsPaused = cppPaused || !cppRunning;
                const inSync = jsExpectsPaused === cppIsPaused;
                
                console.log('Synchronization:', inSync ? '✅ IN SYNC' : '❌ OUT OF SYNC');
                console.log('=======================');
                
                return inSync;
            } catch(e) {
                console.log('Error checking sync state:', e);
                return false;
            }
        };
        
        // Function to force synchronization
        window.forceSyncState = function() {
            console.log('🔄 Forcing state synchronization...');
            
            if (!checkSyncState()) {
                console.log('⚠️ States out of sync - attempting to fix...');
                
                try {
                    if (typeof Module !== 'undefined') {
                        const cppPaused = Module._isGamePaused ? Module._isGamePaused() : false;
                        
                        if (isPaused && !cppPaused) {
                            console.log('JS paused but C++ running - pausing C++');
                            simulateKeyPress('Escape', { skipFocus: true });
                        } else if (!isPaused && cppPaused) {
                            console.log('JS running but C++ paused - resuming C++');
                            simulateKeyPress('Escape', { restoreFocus: true });
                        }
                    }
                } catch(e) {
                    console.log('Error during sync:', e);
                }
                
                // Recheck after sync attempt
                setTimeout(() => {
                    checkSyncState();
                }, 200);
            }
        };
        
        // Event listener per la tastiera
    // Small cooldown to avoid rapid pause toggles (ms)
    const PAUSE_TOGGLE_COOLDOWN_MS = 250;
    let lastPauseToggleMs = 0;

        document.addEventListener('keydown', function(event) {
            console.log('Key pressed:', event.key, event.code, 'isTrusted=', event.isTrusted, 'target=', event.target.tagName, event.target.id);

            // Ignore synthetic (programmatically-dispatched) keyboard events so
            // simulateKeyPress() (which dispatches events to the canvas) doesn't
            // bubble up and trigger the JS handlers again, causing double toggles.
            if (!event.isTrusted) {
                console.log('Ignoring synthetic key event:', event.key);
                return;
            }

            // For ESC key, we want to handle it even if canvas has focus
            // to ensure menu system works properly
            const isEscKey = event.key === 'Escape' || event.code === 'Escape';
            
            // Also ignore events whose target is the canvas element, EXCEPT for ESC
            // key events are dispatched directly to the canvas and should be
            // handled by the C++ engine (via Emscripten). If they bubble up to
            // document we must not handle them again in JS.
            if (!isEscKey) {
                try {
                    const canvasEl = (typeof Module !== 'undefined' && Module.canvas) ? Module.canvas : document.getElementById('canvas');
                    if (canvasEl && event.target === canvasEl) {
                        console.log('Ignoring non-ESC key event targeted at canvas:', event.key);
                        return;
                    }
                } catch (e) {
                    // ignore lookup errors
                }
            }
            
            // INVIO - riavvia tutto FORZATAMENTE
            if (event.key === 'Enter' || event.code === 'Enter') {
                console.log('🔄 ENTER pressed - FORCING complete restart');
                event.preventDefault();
                
                // FORZA il restart completo
                forceCompleteRestart();
                return;
            }
            
            if (event.key === 'Escape' || event.code === 'Escape') {
                console.log('ESC pressed - checking conditions');
                event.preventDefault();
                
                // Check if any pause menu is already visible
                const mobilePauseMenu = document.getElementById('mobilePauseMenu');
                const desktopPauseMenu = document.getElementById('desktopPauseMenu');
                
                if (mobilePauseMenu && mobilePauseMenu.classList.contains('active')) {
                    console.log('📱 Mobile menu visibile - chiudendo menu');
                    hideMobilePauseMenu();
                    return;
                }
                
                if (desktopPauseMenu && desktopPauseMenu.classList.contains('active')) {
                    console.log('🖥️ Desktop menu visibile - chiudendo menu');
                    hideDesktopPauseMenu();
                    return;
                }
                
                // Se è in corso un long press, ignora ESC
                if (longPressTriggered) {
                    console.log('📱 Long press in corso - ignorando ESC');
                    return;
                }
                
                // ESC da tastiera fisica - gestisci normalmente
                if (!isGameOver) {
                    const now = Date.now();
                    if (now - lastPauseToggleMs < PAUSE_TOGGLE_COOLDOWN_MS) {
                        console.log('Ignorato ESC rapido (cooldown)');
                        return;
                    }
                    lastPauseToggleMs = now;

                    if (isPaused) {
                        console.log('FORCING resume da tastiera');
                        forceResume('keyboard');
                        
                        // Also resume C++ game
                        setTimeout(() => {
                            try {
                                if (typeof Module !== 'undefined' && Module._isGamePaused && Module._isGamePaused()) {
                                    simulateKeyPress('Escape');
                                }
                            } catch(e) {
                                console.log('Error resuming C++ game:', e);
                            }
                        }, 50);
                        
                    } else {
                        console.log('FORCING pause da tastiera');
                        forcePause('keyboard');
                        
                        // Pause C++ game first, but be smarter about focus
                        setTimeout(() => {
                            try {
                                if (typeof Module !== 'undefined' && Module._isGameRunning && Module._isGameRunning() && !Module._isGamePaused()) {
                                    // Don't steal focus when pausing - we want to keep control for menu
                                    simulateKeyPress('Escape', { skipFocus: true });
                                    console.log('🎮 C++ game paused via keyboard');
                                }
                            } catch(e) {
                                console.log('Error pausing C++ game:', e);
                            }
                        }, 50);
                        
                        // Show appropriate pause menu
                        setTimeout(() => {
                            if (window.innerWidth <= 768) {
                                console.log('📱 Showing mobile pause menu');
                                showMobilePauseMenu();
                            } else {
                                console.log('🖥️ Showing desktop pause menu');
                                showDesktopPauseMenu();
                            }
                        }, 100);
                    }
                }
            }
            
            // INVIO per ricominciare
            if (event.key === 'Enter' || event.code === 'Enter') {
                console.log('ENTER key detected');
                
                if (isGameOver) {
                    // Se siamo in game over, riavvia immediatamente
                    console.log('� Restarting game from game over state');
                    restartTimer();
                } else if (lastScore > 0) {
                    // Se abbiamo un punteggio e premiamo INVIO, potrebbe essere per ricominciare
                    console.log('🔍 ENTER pressed during game, triggering game over first');
                    stopTimer();
                    
                    // Poi riavvia dopo un breve delay
                    setTimeout(() => {
                        console.log('🔄 Auto-restarting after ENTER');
                        restartTimer();
                    }, 500);
                } else {
                    // Punteggio 0, probabilmente nuovo gioco
                    console.log('🆕 ENTER pressed with score 0, ensuring timer is active');
                    if (!isTimerRunning) {
                        restartTimer();
                    }
                }
            }
            
            // Per test: Ctrl+G per trigger game over
            if (event.ctrlKey && event.key === 'g') {
                console.log('Manual game over triggered');
                stopTimer();
            }
        });
        
        // Funzione per riavviare il timer per una nuova partita
        function restartTimer() {
            console.log('🔄 Restarting timer AND game');
            
            // Reset completo
            isGameOver = false;
            isTimerRunning = true;
            isPaused = false;  // Reset anche lo stato pausa
            gameEndTime = null;
            gameStartTimeReal = Date.now();
            totalPausedTime = 0;
            pauseStartTime = null;
            lastScoreChangeTime = Date.now();
            lastScoreCheck = 0;
            scoreStuckCount = 0;
            
            // RESET GAME OVER STATE - FONDAMENTALE!
            newGameOverActive = false;
            mobileGameOverActive = false;
            lastKnownScore = 0;
            
            // Reset display
            const gameTimeElement = document.getElementById('gameTime');
            const gameStateElement = document.getElementById('gameState');
            
            if (gameTimeElement) {
                gameTimeElement.style.color = '';
                gameTimeElement.textContent = '00:00';
            }
            
            if (gameStateElement) {
                gameStateElement.style.color = '';
                gameStateElement.style.textShadow = '';
                gameStateElement.textContent = 'In corso';
            }
            
            // Riavvia anche il gioco C++
            try {
                if (typeof Module !== 'undefined') {
                    // Usa la nuova funzione dedicata per il restart
                    if (Module._restartTetrisGame) {
                        console.log('🎮 Restarting with _restartTetrisGame...');
                        Module._restartTetrisGame();
                    } else if (Module._startTetrisGame) {
                        console.log('🎮 Restarting with _startTetrisGame...');
                        Module._startTetrisGame();
                    } else {
                        console.log('⚠️ No restart function found. Available functions:');
                        window.listModuleFunctions();
                        console.log('💡 Use window.listModuleFunctions() to see all available functions');
                    }
                } else {
                    console.log('⚠️ Module not available yet');
                }
            } catch(e) {
                console.error('Error restarting C++ game:', e);
            }
            
            console.log('✅ Timer and game restarted');
        }
        
        // Funzioni esposte per test manuali
        window.restartTimer = restartTimer;
        window.forceGameOver = function() {
            console.log('🧪 Forcing game over for testing');
            stopTimer();
        };
        
        window.gameInfo = function() {
            console.log('🎮 Game State:', {
                isGameOver: isGameOver,
                isTimerRunning: isTimerRunning,
                lastScore: lastScore,
                scoreStuckCount: scoreStuckCount,
                timeElapsed: gameStartTimeReal ? Math.floor((Date.now() - gameStartTimeReal) / 1000) + 's' : 'Not started'
            });
        };
        
        // Aggiungi pulsante di test nella console
        console.log('🎮 Tetris Timer Controls:');
        console.log('  pauseTimer() - Pausa il timer');
        console.log('  resumeTimer() - Riprende il timer');
        console.log('  forceGameOver() - Forza game over');
        console.log('  restartTimer() - Riavvia per nuovo gioco');
        console.log('  checkGameState() - Mostra stato attuale');
        console.log('\n⏸️ Auto-Pause Testing:');
        console.log('  testAutoPause() - Testa pausa automatica');
        console.log('  testAutoResume() - Testa resume automatico');
        console.log('  simulateBackground() - Simula background');
        console.log('  simulateForeground() - Simula foreground');
        console.log('\n🖥️ Desktop Menu Testing:');
        console.log('  showDesktopMenu() - Mostra menu desktop');
        console.log('  hideDesktopMenu() - Nascondi menu desktop');
        console.log('\n� Game Over Screen Testing:');
        console.log('  testGameOver(score, level, lines) - Testa schermata game over');
        console.log('  testNewRecordGameOver() - Testa nuovo record');
        console.log('  testLowScoreGameOver() - Testa punteggio basso');
        console.log('  hideGameOverTest() - Nascondi schermata game over');
        console.log('  checkGameOverState() - Verifica stato game over');
        console.log('  forceResetGameOverState() - Reset forzato stato');
        console.log('  restartGameOverMonitoring() - Riavvia monitoring');
        console.log('  testGameOverSequence() - Test sequenza completa');
        console.log('  resetHighScore() - Reset record personale');
        console.log('\n�🔄 State Synchronization:');
        console.log('  checkSyncState() - Verifica sincronizzazione JS/C++');
        console.log('  forceSyncState() - Forza sincronizzazione stati');
        console.log('\n⌨️ Keyboard Controls:');
        console.log('  ESC - Pausa/Riprendi');
        console.log('  ENTER - Riavvia gioco');
        console.log('  Ctrl+G - Forza game over');
        console.log('\n📱 Mobile Game Over Controls:');
        console.log('  👆 Tap pulsanti - Riavvia o Menu');
        console.log('  ⬆️ Swipe up - Riavvia veloce');
        console.log('  ⬇️ Swipe down - Torna al menu');
        console.log('  👆👆 Double tap - Riavvia');
        console.log('\n🔄 Auto-Pause Active: Il gioco si metterà automaticamente in pausa quando:');
        console.log('  - Cambi tab nel browser');
        console.log('  - Metti l\'app in background su mobile');
        console.log('  - La finestra perde il focus');
        console.log('\n💡 Prova subito: testGameOver(5000, 7, 42) per vedere la nuova schermata!');
        
        function updateStatsFromCanvasOrEvents() {
            // Usa le funzioni C++ esportate per ottenere le statistiche reali
            if (typeof Module !== 'undefined' && Module._getScore && Module._getLevel && Module._getLines) {
                try {
                    updateStatsFromCpp();
                } catch(e) {
                    console.error('Error calling C++ functions:', e);
                    updateStatsFallback();
                }
            } else {
                updateStatsFallback();
            }
        }
        
        function updateStatsFromCpp() {
            try {
                // Debug: verifica se le funzioni esistono
                console.log('Module functions available:', {
                    getScore: typeof Module._getScore,
                    getLevel: typeof Module._getLevel,
                    getLines: typeof Module._getLines,
                    isGameRunning: typeof Module._isGameRunning
                });
                
                // Chiama le funzioni C++ per ottenere i valori reali
                const currentScore = Module._getScore();
                const currentLevel = Module._getLevel();
                const currentLines = Module._getLines();
                const gameRunning = Module._isGameRunning();
                
                console.log('Raw C++ values:', {currentScore, currentLevel, currentLines, gameRunning});
                
                // Aggiorna sempre i valori (rimuovo il controllo gameRunning per debug)
                lastScore = currentScore;
                lastLevel = currentLevel;
                lastLines = currentLines;
                
                // Aggiorna gli elementi HTML
                const scoreDisplay = document.getElementById('scoreDisplay');
                const levelDisplay = document.getElementById('levelDisplay');
                const linesDisplay = document.getElementById('linesDisplay');
                
                console.log('HTML elements found:', {
                    scoreDisplay: !!scoreDisplay,
                    levelDisplay: !!levelDisplay,
                    linesDisplay: !!linesDisplay
                });
                
                if (scoreDisplay) scoreDisplay.textContent = lastScore.toLocaleString();
                if (levelDisplay) levelDisplay.textContent = lastLevel;
                if (linesDisplay) linesDisplay.textContent = lastLines;
                
                // Check if game restarted (score=0, level=1, gameRunning=true)
                if (gameRunning && currentScore === 0 && currentLevel === 1 && isGameOver) {
                    console.log('🔄 Game restart detected - resetting info panel');
                    resetGameInfo();
                }
                
                // Simple detection: if score goes from >0 to 0, might be game over
                if (lastScore > 0 && currentScore === 0 && !isGameOver) {
                    console.log('💀 Possible game over: score reset to 0');
                    // Don't auto-trigger, let user use ENTER to restart
                }
                
                // Aggiorna il record se necessario
                if (lastScore > highScore) {
                    highScore = lastScore;
                    localStorage.setItem('tetris-high-score', highScore);
                    const highScoreElement = document.getElementById('highScore');
                    if (highScoreElement) {
                        highScoreElement.textContent = parseInt(highScore).toLocaleString();
                        // Effetto visivo per nuovo record
                        highScoreElement.style.color = '#ff9800';
                        highScoreElement.style.textShadow = '0 0 15px #ff9800';
                        setTimeout(() => {
                            highScoreElement.style.color = '';
                            highScoreElement.style.textShadow = '';
                        }, 2000);
                    }
                }
                
                console.log('Stats updated from C++:', {score: lastScore, level: lastLevel, lines: lastLines, running: gameRunning});
                
            } catch(e) {
                console.error('Error in updateStatsFromCpp:', e);
                updateStatsFallback();
            }
        }
        
        function updateStatsSimulated() {
            // Fallback per quando Module.HEAP32 non è disponibile
            console.log('Using simulated stats (Module.HEAP32 not available)');
            
            // Prova comunque a usare le funzioni C++ esportate se disponibili
            if (typeof Module !== 'undefined' && Module._getScore && Module._getLevel && Module._getLines) {
                try {
                    updateStatsFromCpp();
                    return;
                } catch(e) {
                    console.error('Error calling C++ functions in simulation mode:', e);
                }
            }
            
            // Se proprio non funziona nulla, usa il fallback
            updateStatsFallback();
        }
        
        function updateStatsFallback() {
            // Fallback: mantieni i valori precedenti o usa valori di default
            const scoreDisplay = document.getElementById('scoreDisplay');
            const levelDisplay = document.getElementById('levelDisplay');
            const linesDisplay = document.getElementById('linesDisplay');
            
            if (scoreDisplay && !scoreDisplay.textContent) scoreDisplay.textContent = '0';
            if (levelDisplay && !levelDisplay.textContent) levelDisplay.textContent = '1';
            if (linesDisplay && !linesDisplay.textContent) linesDisplay.textContent = '0';
        }
        
        function resetGameInfo() {
            console.log('🔄 Starting resetGameInfo...');
            
            // Reset game state
            isGameOver = false;
            isPaused = false;
            isTimerRunning = true;
            
            // Reset game over state - QUESTO È FONDAMENTALE!
            newGameOverActive = false;
            mobileGameOverActive = false;
            
            // Reset time tracking
            gameStartTimeReal = Date.now();
            gameEndTime = null;
            totalPausedTime = 0;
            pauseStartTime = null;
            
            // Reset score tracking for game over detection
            lastKnownScore = 0;
            lastScoreChangeTime = Date.now();
            
            console.log('🔄 Reset timer variables:', {
                gameStartTimeReal: new Date(gameStartTimeReal).toLocaleTimeString(),
                isTimerRunning,
                isPaused,
                isGameOver,
                newGameOverActive,
                mobileGameOverActive
            });
            
            // Update game state element
            const gameStateElement = document.getElementById('gameState');
            if (gameStateElement) {
                gameStateElement.textContent = 'In corso';
                gameStateElement.style.color = '';
                console.log('🔄 Updated game state display to "In corso"');
            }
            
            // Reset time display (remove FINAL)
            const gameTimeElement = document.getElementById('gameTime');
            if (gameTimeElement) {
                gameTimeElement.textContent = '00:00';
                gameTimeElement.style.color = '';
                console.log('🔄 Reset time display to "00:00"');
            }
            
            // Assicurati che l'overlay game over sia nascosto
            const gameOverOverlay = document.getElementById('gameOverOverlay');
            if (gameOverOverlay) {
                gameOverOverlay.classList.remove('active');
                gameOverOverlay.style.display = 'none';
            }
            
            console.log('✅ Game info reset complete - game over state cleared');
        }
        
        function stopStatsUpdater() {
            if (statsUpdateInterval) {
                clearInterval(statsUpdateInterval);
                statsUpdateInterval = null;
            }
        }
        
        // Marca l'inizio del gioco per le statistiche
        window.gameStartTime = Date.now();
        
        // Responsive layout function
        function fitCanvasToViewport() {
            console.log('Fitting canvas to viewport...');
            
            const gameWrapper = document.querySelector('.game-wrapper');
            const gameLayout = document.querySelector('.game-layout');
            const canvas = document.getElementById('canvas');
            
            if (!gameWrapper || !gameLayout || !canvas) return;
            
            // Calculate available space
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            const isMobile = viewportWidth <= 768;
            
            if (isMobile) {
                // Mobile: smaller canvas to fit stats and info panels
                const reservedHeight = 280; // header + stats + info + footer + padding
                const maxCanvasHeight = Math.min(viewportHeight - reservedHeight, 420);
                const maxCanvasWidth = Math.min(viewportWidth * 0.7, 360); // smaller width
                
                canvas.style.maxWidth = maxCanvasWidth + 'px';
                canvas.style.maxHeight = maxCanvasHeight + 'px';
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
                
                // Ensure canvas is perfectly centered and aligned with stats/info
                canvas.style.display = 'block';
                canvas.style.margin = '0 auto';
                canvas.style.position = 'static';
                canvas.style.left = 'auto';
                canvas.style.transform = 'none';
                
                // Center the game wrapper and ensure consistent alignment
                gameWrapper.style.margin = '0 auto';
                gameWrapper.style.maxWidth = '95vw';
                gameWrapper.style.textAlign = 'center';
                
                // Ensure game canvas container aligns with stats panels
                const gameCanvasContainer = document.querySelector('.game-canvas');
                if (gameCanvasContainer) {
                    gameCanvasContainer.style.justifyContent = 'center';
                    gameCanvasContainer.style.alignItems = 'center';
                    gameCanvasContainer.style.width = '100%';
                    gameCanvasContainer.style.textAlign = 'center';
                }
            } else {
                // Desktop: center layout with stats panels
                canvas.style.maxWidth = '';
                canvas.style.maxHeight = '';
                canvas.style.width = 'auto';
                canvas.style.height = 'auto';
                
                // Center the game wrapper
                gameWrapper.style.margin = '0 auto';
                gameWrapper.style.maxWidth = '1200px';
            }
            
            console.log('Canvas fitted:', { isMobile, viewportWidth, viewportHeight });
        }
        
    /*
     Mobile touch controls and long-press handling

     Changes added: prevent the pause menu from opening on rapid consecutive taps.
     - Implements a true long-press detection (LONG_PRESS_TIME)
     - Suppresses long-press if user performed a burst of quick taps (recentTapCount)
     - Adds a short cooldown after a successful long-press to avoid immediate re-triggering
     These guards prevent accidental pause menu openings on mobile when users tap
     quickly multiple times. Adjust LONG_PRESS_TIME, TAP_BURST_THRESHOLD and
     LONG_PRESS_COOLDOWN to tune behavior.
    */
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let lastTapTime = 0;
        const TAP_DEBOUNCE = 250; // ms
        const TAP_HOLD_TIME = 300; // ms max for a tap
        const LONG_PRESS_TIME = 2000; // ms for long press (2 seconds)
        let longPressTimer = null;
        let longPressTriggered = false;
        let touchMoved = false;
        let mobilePauseActive = false; // Track mobile pause state
        // Anti-accidental-open guards
        let recentTapCount = 0;           // number of quick taps in a short burst
        let tapBurstResetTimer = null;   // timer to reset recentTapCount
        const TAP_BURST_WINDOW = 700;    // ms window to consider taps part of a burst
        const TAP_BURST_THRESHOLD = 3;   // if >=this in window, suppress long-press briefly
        let lastLongPressTime = 0;       // timestamp of last successful long-press
        const LONG_PRESS_COOLDOWN = 1200; // ms cooldown after a long-press
    // Track whether a touch started on the canvas so body fallback ignores it
    let canvasTouchActive = false;
        // Throttle for lateral moves to prevent multiple rapid moves from a single swipe
        let lastLateralMoveTime = 0;
        const MOVE_THROTTLE_MS = 120; // ms between lateral moves

        function attemptLateralMove(direction) {
            const now = Date.now();
            if (now - lastLateralMoveTime < MOVE_THROTTLE_MS) {
                // too soon, ignore
                //console.log('Lateral move throttled');
                return false;
            }
            lastLateralMoveTime = now;
            if (direction === 'left') simulateKeyPress('ArrowLeft');
            else simulateKeyPress('ArrowRight');
            return true;
        }

        function addTouchControls() {
            const canvas = document.getElementById('canvas');
            if (!canvas) return;

            // dynamically compute swipe threshold based on canvas size
            function getMinSwipeDistance() {
                const w = Math.max(200, canvas.clientWidth || window.innerWidth);
                return Math.max(18, Math.min(60, Math.round(w * 0.12))); // 12% of canvas width, clamped
            }

            // Prevent default touch behaviors
            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) return; // ignore multi-touch
                e.preventDefault();
                e.stopPropagation();
                canvasTouchActive = true;
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartTime = Date.now();
                longPressTriggered = false;
                touchMoved = false;
                
                // Start long press timer only if touch stays still
                // Reset any previous long press timer for safety
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                longPressTimer = setTimeout(() => {
                    // Double check: only trigger if no movement occurred, timer wasn't cancelled,
                    // the touch actually lasted LONG_PRESS_TIME, and we're not in a recent tap burst.
                    const now = Date.now();
                    const actualTouchDuration = now - touchStartTime;

                    // Suppress if a long-press was triggered very recently
                    if (now - lastLongPressTime < LONG_PRESS_COOLDOWN) {
                        console.log('🚫 Ignoring long press due to cooldown');
                        return;
                    }

                    // If quick tap burst detected, don't allow accidental long-presses
                    if (recentTapCount >= TAP_BURST_THRESHOLD) {
                        console.log('🚫 Suppressing long press due to recent tap burst:', recentTapCount);
                        return;
                    }

                    // Finally ensure movement didn't occur and duration is sufficient
                    if (!touchMoved && longPressTimer !== null && canvasTouchActive && actualTouchDuration >= LONG_PRESS_TIME) {
                        longPressTriggered = true;
                        lastLongPressTime = now;
                        console.log('✅ Long press activated - conditions met (duration:', actualTouchDuration + 'ms)');
                        showMobilePauseMenu();
                    } else {
                        console.log('❌ Long press cancelled - movement detected, too short, or timer cleared', { touchMoved, actualTouchDuration });
                    }
                }, LONG_PRESS_TIME);
            }, { passive: false });

            canvas.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) return; // ignore multi-touch
                e.preventDefault();
                
                const touch = e.touches[0];
                const deltaX = Math.abs(touch.clientX - touchStartX);
                const deltaY = Math.abs(touch.clientY - touchStartY);
                
                // If significant movement, cancel long press (but only if not already triggered)
                if (deltaX > 20 || deltaY > 20) { // Increased threshold to be even less sensitive
                    if (!longPressTriggered && !touchMoved) {
                        touchMoved = true;
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                            console.log('🚫 Long press cancelled due to movement:', { deltaX, deltaY });
                        }
                    }
                }
            }, { passive: false });

            canvas.addEventListener('touchend', function(e) {
                if (e.changedTouches.length > 1) return; // ignore multi-touch
                e.preventDefault();
                e.stopPropagation();

                // If long press was already triggered, don't cancel it
                if (longPressTriggered) {
                    console.log('✅ Long press was triggered, keeping it active');
                    canvasTouchActive = false;
                    touchMoved = false; // Reset for next touch
                    longPressTriggered = false; // Reset for next touch
                    return;
                }

                // Only clear timer if long press wasn't triggered
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    const touchDuration = Date.now() - touchStartTime;
                    console.log('🚫 Long press timer cancelled - touch too short:', touchDuration + 'ms');
                }

                // Compute touch end coordinates first (fix TDZ ReferenceError)
                const touch = e.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;
                const touchEndTime = Date.now();

                // If this was a short tap (not a swipe), account it in recentTapCount so
                // a burst of quick taps doesn't accidentally allow a long-press immediately after.
                if (Math.abs(touchEndX - touchStartX) < 20 && Math.abs(touchEndY - touchStartY) < 20 && (touchEndTime - touchStartTime) < TAP_HOLD_TIME) {
                    recentTapCount++;
                    if (tapBurstResetTimer) clearTimeout(tapBurstResetTimer);
                    tapBurstResetTimer = setTimeout(() => {
                        recentTapCount = 0;
                        tapBurstResetTimer = null;
                    }, TAP_BURST_WINDOW);
                    console.log('🔔 Registered quick tap, burst count:', recentTapCount);
                }

                if (!gameStartRequested) {
                    canvasTouchActive = false;
                    touchMoved = false; // Reset for next touch
                    return;
                }

                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const deltaTime = touchEndTime - touchStartTime;

                const minSwipeDistance = getMinSwipeDistance();

                // Short tap -> rotate (debounced)
                if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance && deltaTime < TAP_HOLD_TIME) {
                    const now = Date.now();
                    if (now - lastTapTime > TAP_DEBOUNCE) {
                        lastTapTime = now;
                        simulateKeyPress('ArrowUp');
                        console.log('🔄 Tap rotate executed');
                    } else {
                        console.log('Tap ignored due to debounce');
                    }
                    canvasTouchActive = false;
                    touchMoved = false; // Reset for next touch
                    return;
                }

                // Horizontal swipe (move left/right)
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0) attemptLateralMove('right'); else attemptLateralMove('left');
                    canvasTouchActive = false;
                    return;
                }

                // Vertical swipe down (fast drop)
                if (deltaY > Math.abs(deltaX) && Math.abs(deltaY) > minSwipeDistance) {
                    simulateKeyPress('ArrowDown');
                    canvasTouchActive = false;
                    return;
                }

                canvasTouchActive = false;
            }, { passive: false });

            // Prevent scrolling and zooming when touching the canvas
            canvas.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) return;
                e.preventDefault();
            }, { passive: false });
        }

        function simulateKeyPress(key, options = {}) {
            console.log('Simulating key press:', key, options);

            // Prefer dispatching to the canvas element used by Module
            const targetCanvas = (typeof Module !== 'undefined' && Module.canvas) ? Module.canvas : document.getElementById('canvas');
            if (!targetCanvas) return;

            const keyCode = getKeyCode(key) || 0;

            // Prevent dispatching the same simulated key too frequently
            if (!simulateKeyPress._lastDispatch) simulateKeyPress._lastDispatch = {};
            const last = simulateKeyPress._lastDispatch[key] || 0;
            const now = Date.now();
            const SIMULATE_KEY_COOLDOWN_MS = 120; // small cooldown for simulated keys
            if (now - last < SIMULATE_KEY_COOLDOWN_MS) {
                console.log('Skipping simulated key (cooldown):', key);
                return;
            }
            simulateKeyPress._lastDispatch[key] = now;

            // Store current focus to restore later if needed
            const currentFocus = document.activeElement;
            const shouldRestoreFocus = options.restoreFocus !== false && currentFocus !== targetCanvas;

            try {
                // Ensure the canvas has focus so SDL receives keyboard events
                // But only if not explicitly disabled
                if (options.skipFocus !== true && typeof targetCanvas.focus === 'function') {
                    try { targetCanvas.focus({ preventScroll: true }); } catch(e) { targetCanvas.focus(); }
                }

                // Dispatch keydown
                const keyDownEvent = new KeyboardEvent('keydown', {
                    key: key,
                    code: key,
                    keyCode: keyCode,
                    which: keyCode,
                    bubbles: true,
                    cancelable: true
                });
                targetCanvas.dispatchEvent(keyDownEvent);

                // Also dispatch a keypress event which some engines expect
                const keyPressEvent = new KeyboardEvent('keypress', {
                    key: key,
                    code: key,
                    keyCode: keyCode,
                    which: keyCode,
                    bubbles: true,
                    cancelable: true
                });
                targetCanvas.dispatchEvent(keyPressEvent);

                // Hold key a bit longer to help native SDL handlers capture it
                const KEY_HOLD_MS = 180;
                setTimeout(() => {
                    const keyUpEvent = new KeyboardEvent('keyup', {
                        key: key,
                        code: key,
                        keyCode: keyCode,
                        which: keyCode,
                        bubbles: true,
                        cancelable: true
                    });
                    targetCanvas.dispatchEvent(keyUpEvent);
                    
                    // Restore focus if requested and safe to do so
                    if (shouldRestoreFocus && currentFocus && typeof currentFocus.focus === 'function') {
                        try {
                            // Wait a bit more to ensure C++ has processed the key
                            setTimeout(() => {
                                if (document.body.contains(currentFocus)) {
                                    currentFocus.focus({ preventScroll: true });
                                    console.log('Focus restored to:', currentFocus.tagName, currentFocus.id);
                                }
                            }, 50);
                        } catch(e) {
                            console.log('Could not restore focus:', e);
                        }
                    }
                }, KEY_HOLD_MS);
            } catch (e) {
                console.error('simulateKeyPress error:', e);
            }
        }
        
        function getKeyCode(key) {
            const codes = {
                'ArrowUp': 38,
                'ArrowDown': 40,
                'ArrowLeft': 37,
                'ArrowRight': 39,
                'Up': 38,
                'Down': 40,
                'Left': 37,
                'Right': 39
            };
            return codes[key] || 0;
        }

        // Initialize touch controls immediatamente e quando il container diventa visibile
        setTimeout(() => {
            console.log('Adding touch controls immediately...');
            addTouchControls();
        }, 1000);
        
        // Fallback: aggiungi controlli touch anche al body per essere sicuri
        function addBodyTouchControls() {
            console.log('Adding fallback touch controls to body');

            // Reuse same helpers as canvas handlers
            function getMinSwipeDistanceForBody() {
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    const w = Math.max(200, canvas.clientWidth || window.innerWidth);
                    return Math.max(18, Math.min(60, Math.round(w * 0.12)));
                }
                return Math.max(18, Math.round(window.innerWidth * 0.12));
            }

            document.body.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) return;
                // If the touch originated on the canvas we should ignore here
                if (canvasTouchActive) return;
                if (gameStartRequested) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    touchStartTime = Date.now();
                }
            }, { passive: false });

            document.body.addEventListener('touchend', function(e) {
                if (e.changedTouches.length > 1) return;
                // Ignore if canvas handled it
                if (canvasTouchActive) return;
                if (!gameStartRequested) return;

                e.stopPropagation();

                const touch = e.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;
                const touchEndTime = Date.now();

                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const deltaTime = touchEndTime - touchStartTime;

                const minSwipeDistance = getMinSwipeDistanceForBody();

                // Tap (rotate) with debounce
                if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance && deltaTime < TAP_HOLD_TIME) {
                    const now = Date.now();
                    if (now - lastTapTime > TAP_DEBOUNCE) {
                        lastTapTime = now;
                        simulateKeyPress('ArrowUp');
                    }
                    return;
                }

                // Horizontal swipe
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0) attemptLateralMove('right'); else attemptLateralMove('left');
                    return;
                }

                // Vertical swipe down
                if (deltaY > Math.abs(deltaX) && Math.abs(deltaY) > minSwipeDistance) {
                    simulateKeyPress('ArrowDown');
                    return;
                }
            }, { passive: false });
        }
        
        // Attiva anche i controlli body
        setTimeout(addBodyTouchControls, 500);
        
        // ==================== MOBILE TOUCH SUPPORT PER GAME OVER ====================
        
        /**
         * Aggiunge supporto touch per la schermata game over
         */
        function addGameOverTouchSupport() {
            const gameOverOverlay = document.getElementById('gameOverOverlay');
            if (!gameOverOverlay) return;
            
            // Supporto per swipe per riavviare su mobile
            let gameOverTouchStartY = 0;
            let gameOverTouchStartTime = 0;
            
            gameOverOverlay.addEventListener('touchstart', function(e) {
                if (!newGameOverActive) return;
                
                const touch = e.touches[0];
                gameOverTouchStartY = touch.clientY;
                gameOverTouchStartTime = Date.now();
            }, { passive: true });
            
            gameOverOverlay.addEventListener('touchend', function(e) {
                if (!newGameOverActive) return;
                
                const touch = e.changedTouches[0];
                const touchEndY = touch.clientY;
                const touchDuration = Date.now() - gameOverTouchStartTime;
                const deltaY = gameOverTouchStartY - touchEndY;
                
                // Swipe up per riavviare (almeno 50px di movimento, max 800ms)
                if (deltaY > 50 && touchDuration < 800) {
                    console.log('🎮 Swipe up detected in game over - restarting');
                    restartFromGameOver();
                }
                // Swipe down per menu (almeno 50px di movimento, max 800ms) 
                else if (deltaY < -50 && touchDuration < 800) {
                    console.log('🏠 Swipe down detected in game over - returning to menu');
                    returnToMainMenu();
                }
            }, { passive: true });
            
            // Doppio tap per riavviare velocemente
            let lastGameOverTap = 0;
            const DOUBLE_TAP_DELAY = 300;
            
            gameOverOverlay.addEventListener('touchend', function(e) {
                if (!newGameOverActive) return;
                
                // Ignora se è un pulsante specifico
                if (e.target.classList.contains('gameover-btn') || 
                    e.target.closest('.gameover-btn')) return;
                
                const now = Date.now();
                if (now - lastGameOverTap < DOUBLE_TAP_DELAY) {
                    console.log('🎮 Double tap detected in game over - restarting');
                    restartFromGameOver();
                } else {
                    lastGameOverTap = now;
                }
            }, { passive: true });
            
            console.log('✅ Game over touch support added');
        }
        
        // Inizializza il supporto touch per game over quando il DOM è pronto
        setTimeout(addGameOverTouchSupport, 100);
        
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (gameContainer.classList.contains('visible')) {
                        console.log('Game container visible, re-adding touch controls...');
                        setTimeout(addTouchControls, 100);
                        observer.disconnect();
                    }
                }
            });
        });

        observer.observe(gameContainer, { attributes: true });

        // Add resize and orientation change listeners
        window.addEventListener('resize', fitCanvasToViewport);
        window.addEventListener('orientationchange', () => {
            setTimeout(fitCanvasToViewport, 100); // delay for orientation to complete
        });
        
        // Auto-pause system when game goes to background (mobile and desktop)
        let wasAutoPaused = false;
        let autoPauseReason = '';
        
        // Primary method: Page Visibility API (works on all modern browsers)
        document.addEventListener('visibilitychange', function() {
            if (!gameStartRequested || isGameOver) return;
            
            if (document.hidden && !isPaused) {
                // Page is hidden (tab switch, app background, etc.)
                console.log('🔄 Auto-pausing: page went to background');
                wasAutoPaused = true;
                autoPauseReason = 'background';
                forcePause('background');
                
                // Also pause the C++ game engine
                try {
                    if (typeof Module !== 'undefined' && Module._isGameRunning && Module._isGameRunning() && !Module._isGamePaused()) {
                        simulateKeyPress('Escape');
                        console.log('🎮 C++ game also paused for background');
                    }
                } catch(e) {
                    console.log('Error pausing C++ game:', e);
                }
            } else if (!document.hidden && wasAutoPaused && autoPauseReason === 'background') {
                // Page is visible again
                console.log('👀 Page back to foreground - showing resume options');
                showResumeDialog();
            }
        });
        
        // Secondary method: Window focus/blur (backup for older browsers)
        window.addEventListener('blur', function() {
            if (!gameStartRequested || isGameOver || document.hidden) return; // visibilitychange already handled it
            
            if (!isPaused) {
                console.log('🔄 Auto-pausing: window lost focus');
                wasAutoPaused = true;
                autoPauseReason = 'blur';
                forcePause('auto');
                
                try {
                    if (typeof Module !== 'undefined' && Module._isGameRunning && Module._isGameRunning() && !Module._isGamePaused()) {
                        simulateKeyPress('Escape');
                        console.log('🎮 C++ game also paused for focus loss');
                    }
                } catch(e) {
                    console.log('Error pausing C++ game:', e);
                }
            }
        });
        
        window.addEventListener('focus', function() {
            if (!gameStartRequested || isGameOver) return;
            
            if (wasAutoPaused && autoPauseReason === 'blur' && !document.hidden) {
                console.log('👀 Window regained focus - showing resume options');
                showResumeDialog();
            }
        });
        
        // Function to show resume dialog/notification
        function showResumeDialog() {
            // Reset auto-pause state
            wasAutoPaused = false;
            autoPauseReason = '';
            
            // On mobile, show the pause menu
            if (window.innerWidth <= 768) {
                console.log('📱 Mobile: showing pause menu for resume');
                const mobilePauseMenu = document.getElementById('mobilePauseMenu');
                if (mobilePauseMenu) {
                    mobilePauseMenu.classList.add('active');
                    mobilePauseActive = true;
                }
            } else {
                // On desktop, show the pause menu
                console.log('🖥️ Desktop: showing pause menu for resume');
                showDesktopPauseMenu();
            }
        }
        
        // Desktop pause menu functions
        function showDesktopPauseMenu() {
            const menu = document.getElementById('desktopPauseMenu');
            if (menu && window.innerWidth > 768) {
                // Update stats in the menu
                updateDesktopPauseMenuStats();
                
                // Show menu
                menu.classList.add('active');
                console.log('🖥️ Desktop pause menu shown');
                
                // Focus the resume button for keyboard accessibility
                setTimeout(() => {
                    const resumeBtn = document.getElementById('desktopResumeBtn');
                    if (resumeBtn) resumeBtn.focus();
                }, 100);
            }
        }
        
        function hideDesktopPauseMenu() {
            const menu = document.getElementById('desktopPauseMenu');
            if (menu) {
                menu.classList.remove('active');
                console.log('🖥️ Desktop pause menu hidden');
            }
        }
        
        function updateDesktopPauseMenuStats() {
            try {
                // Update current game stats in the pause menu
                const scoreEl = document.getElementById('desktopPauseScore');
                const levelEl = document.getElementById('desktopPauseLevel');
                const linesEl = document.getElementById('desktopPauseLines');
                const timeEl = document.getElementById('desktopPauseTime');
                
                if (typeof Module !== 'undefined') {
                    if (scoreEl && Module._getScore) {
                        scoreEl.textContent = Module._getScore().toLocaleString();
                    }
                    if (levelEl && Module._getLevel) {
                        levelEl.textContent = Module._getLevel();
                    }
                    if (linesEl && Module._getLines) {
                        linesEl.textContent = Module._getLines();
                    }
                }
                
                // Update time from the game timer
                if (timeEl) {
                    const gameTimeElement = document.getElementById('gameTime');
                    if (gameTimeElement) {
                        timeEl.textContent = gameTimeElement.textContent.replace(' (PAUSA)', '').replace(' (FINAL)', '');
                    }
                }
            } catch(e) {
                console.log('Error updating pause menu stats:', e);
            }
        }
        
        // Replace the old notification function
        function showDesktopResumeNotification() {
            showDesktopPauseMenu();
        }
        
        // ==================== NUOVA SCHERMATA GAME OVER UNIFICATA ====================
        
        let newGameOverActive = false;
        
        /**
         * Mostra la nuova schermata di game over unificata per desktop e mobile
         */
        function showNewGameOver(score = 0, level = 1, lines = 0, gameTime = '00:00') {
            console.log('🎮 Showing new unified game over screen', { score, level, lines, gameTime, newGameOverActive });
            
            // Se è già attiva, non mostrare di nuovo
            if (newGameOverActive) {
                console.log('⚠️ Game over screen already active, skipping');
                return;
            }
            
            newGameOverActive = true;
            const overlay = document.getElementById('gameOverOverlay');
            const canvas = document.getElementById('canvas');
            
            if (!overlay) {
                console.error('Game over overlay not found');
                newGameOverActive = false; // Reset se non trovato
                return;
            }
            
            // Assicurati che l'overlay sia visibile 
            overlay.style.display = 'flex';
            
            // Nascondi il canvas per evitare sovrapposizioni
            if (canvas) {
                canvas.style.opacity = '0.3';
                canvas.style.pointerEvents = 'none';
            }
            
            // Calcola i dati finali del gioco
            calculateGameOverData(score, level, lines, gameTime);
            
            // Aggiorna tutti gli elementi della schermata
            updateGameOverElements();
            
            // Mostra la schermata con animazione
            overlay.classList.add('active');
            
            // Aggiungi i listener per i controlli da tastiera
            addGameOverKeyboardListeners();
            
            console.log('✅ New game over screen displayed');
        }
        
        /**
         * Nasconde la schermata di game over
         */
        function hideNewGameOver() {
            console.log('🎮 Hiding new game over screen');
            
            newGameOverActive = false;
            const overlay = document.getElementById('gameOverOverlay');
            const canvas = document.getElementById('canvas');
            
            if (overlay) {
                overlay.classList.remove('active');
                
                // Nascondi l'overlay dopo l'animazione
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 500);
            }
            
            // Ripristina la visibilità del canvas
            if (canvas) {
                canvas.style.opacity = '1';
                canvas.style.pointerEvents = 'auto';
            }
            
            // Rimuovi i listener della tastiera
            removeGameOverKeyboardListeners();
            
            // Reset anche dello stato legacy mobile per sicurezza
            mobileGameOverActive = false;
            
            console.log('✅ New game over screen hidden - all states reset');
        }
        
        /**
         * Calcola e prepara i dati per la schermata game over
         */
        function calculateGameOverData(score, level, lines, gameTime) {
            // Ottieni il record precedente
            const previousRecord = parseInt(localStorage.getItem('tetris-high-score') || '0');
            
            // Determina se è un nuovo record
            const isNewRecord = score > previousRecord;
            
            // Salva il nuovo record se necessario
            if (isNewRecord) {
                localStorage.setItem('tetris-high-score', score.toString());
                console.log('� New high score achieved:', score);
            }
            
            // Calcola il tempo totale di gioco
            let totalGameTimeMs = 0;
            if (gameStartTimeReal && gameEndTime) {
                totalGameTimeMs = gameEndTime - gameStartTimeReal - totalPausedTime;
            } else if (gameStartTimeReal) {
                totalGameTimeMs = Date.now() - gameStartTimeReal - totalPausedTime;
            }
            
            const totalGameTimeSeconds = Math.floor(totalGameTimeMs / 1000);
            const minutes = Math.floor(totalGameTimeSeconds / 60);
            const seconds = totalGameTimeSeconds % 60;
            const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Aggiorna i dati globali
            gameOverData = {
                finalScore: score,
                finalLevel: level,
                finalLines: lines,
                finalTime: formattedTime,
                previousRecord: previousRecord,
                isNewRecord: isNewRecord,
                totalGameTime: totalGameTimeMs
            };
            
            console.log('📊 Game over data calculated:', gameOverData);
        }
        
        /**
         * Aggiorna tutti gli elementi HTML della schermata game over
         */
        function updateGameOverElements() {
            // Aggiorna le statistiche finali
            const finalScoreEl = document.getElementById('gameOverFinalScore');
            const finalLevelEl = document.getElementById('gameOverFinalLevel');
            const finalLinesEl = document.getElementById('gameOverFinalLines');
            const finalTimeEl = document.getElementById('gameOverFinalTime');
            
            if (finalScoreEl) finalScoreEl.textContent = gameOverData.finalScore.toLocaleString();
            if (finalLevelEl) finalLevelEl.textContent = gameOverData.finalLevel;
            if (finalLinesEl) finalLinesEl.textContent = gameOverData.finalLines;
            if (finalTimeEl) finalTimeEl.textContent = gameOverData.finalTime;
            
            // Aggiorna la sezione record
            const recordValueEl = document.getElementById('gameOverRecordValue');
            const recordCardEl = document.getElementById('gameOverRecordCard');
            const newRecordBadgeEl = document.getElementById('gameOverNewRecordBadge');
            
            if (recordValueEl) {
                if (gameOverData.isNewRecord) {
                    recordValueEl.textContent = gameOverData.finalScore.toLocaleString();
                } else {
                    recordValueEl.textContent = gameOverData.previousRecord.toLocaleString();
                }
            }
            
            if (recordCardEl) {
                if (gameOverData.isNewRecord) {
                    recordCardEl.classList.add('new-record');
                } else {
                    recordCardEl.classList.remove('new-record');
                }
            }
            
            // Aggiorna il messaggio motivazionale
            const messageEl = document.getElementById('gameOverMessage');
            if (messageEl) {
                const messages = getMotivationalMessage();
                messageEl.textContent = messages.message;
            }
            
            // Aggiorna il sottotitolo
            const subtitleEl = document.getElementById('gameOverSubtitle');
            if (subtitleEl) {
                if (gameOverData.isNewRecord) {
                    subtitleEl.innerHTML = '🏆 Nuovo Record Personale!';
                } else if (gameOverData.finalScore === 0) {
                    subtitleEl.innerHTML = '🎯 Riprova per fare meglio!';
                } else {
                    subtitleEl.innerHTML = '🎮 Partita terminata';
                }
            }
            
            console.log('✅ Game over elements updated');
        }
        
        /**
         * Genera messaggi motivazionali basati sulle prestazioni
         */
        function getMotivationalMessage() {
            const { finalScore, finalLevel, isNewRecord } = gameOverData;
            
            if (isNewRecord) {
                return {
                    message: "🎉 Fantastico! Hai battuto il tuo record personale!",
                    type: "record"
                };
            }
            
            if (finalScore === 0) {
                return {
                    message: "Non preoccuparti, tutti iniziano da qualche parte. Riprova!",
                    type: "beginner"
                };
            }
            
            if (finalScore < 1000) {
                return {
                    message: "Buon inizio! Continua a giocare per migliorare.",
                    type: "starter"
                };
            }
            
            if (finalScore < 5000) {
                return {
                    message: "Ottimo lavoro! Stai migliorando rapidamente.",
                    type: "improving"
                };
            }
            
            if (finalScore < 10000) {
                return {
                    message: "Fantastico! Sei sulla buona strada per diventare un maestro!",
                    type: "advanced"
                };
            }
            
            if (finalLevel >= 10) {
                return {
                    message: "Incredibile! Hai raggiunto un livello molto alto!",
                    type: "expert"
                };
            }
            
            return {
                message: "Ottimo punteggio! Riprova per battere il tuo record!",
                type: "good"
            };
        }
        
        /**
         * Aggiunge i listener per i controlli da tastiera nella schermata game over
         */
        function addGameOverKeyboardListeners() {
            document.addEventListener('keydown', handleGameOverKeyboard);
        }
        
        /**
         * Rimuove i listener per i controlli da tastiera
         */
        function removeGameOverKeyboardListeners() {
            document.removeEventListener('keydown', handleGameOverKeyboard);
        }
        
        /**
         * Gestisce gli input da tastiera nella schermata game over
         */
        function handleGameOverKeyboard(event) {
            if (!newGameOverActive) return;
            
            switch (event.key) {
                case 'Enter':
                    event.preventDefault();
                    console.log('🎮 Enter pressed in game over - restarting');
                    restartFromGameOver();
                    break;
                    
                case 'Escape':
                    event.preventDefault();
                    console.log('🏠 Escape pressed in game over - returning to menu');
                    returnToMainMenu();
                    break;
                    
                case 'r':
                case 'R':
                    event.preventDefault();
                    console.log('🔄 R pressed in game over - restarting');
                    restartFromGameOver();
                    break;
                    
                case 'q':
                case 'Q':
                    event.preventDefault();
                    console.log('🚪 Q pressed in game over - quitting to menu');
                    returnToMainMenu();
                    break;
            }
        }
        
        /**
         * Riavvia il gioco dalla schermata game over
         */
        function restartFromGameOver() {
            console.log('🔄 Restarting game from game over screen');
            
            hideNewGameOver();
            
            // Aspetta che l'animazione finisca, poi riavvia
            setTimeout(() => {
                // Reset completo dello stato in un'unica funzione
                console.log('🔄 Executing complete game restart...');
                
                // Reset tutti gli stati JavaScript
                isGameOver = false;
                isTimerRunning = true; 
                isPaused = false;
                newGameOverActive = false;
                mobileGameOverActive = false;
                lastKnownScore = 0;
                gameStartTimeReal = Date.now();
                gameEndTime = null;
                totalPausedTime = 0;
                pauseStartTime = null;
                lastScoreChangeTime = Date.now();
                
                // Aggiorna display
                const gameTimeElement = document.getElementById('gameTime');
                const gameStateElement = document.getElementById('gameState');
                if (gameTimeElement) {
                    gameTimeElement.textContent = '00:00';
                    gameTimeElement.style.color = '';
                }
                if (gameStateElement) {
                    gameStateElement.textContent = 'In corso';
                    gameStateElement.style.color = '';
                }
                
                // Riavvia il gioco C++
                try {
                    if (typeof Module !== 'undefined') {
                        if (Module._restartTetrisGame) {
                            Module._restartTetrisGame();
                            console.log('✅ C++ game restarted via _restartTetrisGame');
                        } else if (Module._startTetrisGame) {
                            Module._startTetrisGame();
                            console.log('✅ C++ game restarted via _startTetrisGame');
                        }
                    }
                } catch(e) {
                    console.error('Error restarting C++ game:', e);
                }
                
                console.log('✅ Complete game restart finished');
            }, 300);
        }
        
        /**
         * Torna al menu principale dalla schermata game over
         */
        function returnToMainMenu() {
            console.log('🏠 Returning to main menu from game over');
            
            hideNewGameOver();
            
            // Aspetta che l'animazione finisca
            setTimeout(() => {
                // Ferma tutti i timer e reset dello stato
                stopStatsUpdater();
                gameStartRequested = false;
                
                // Nascondi il container del gioco
                const gameContainer = document.querySelector('.game-container');
                if (gameContainer) {
                    gameContainer.classList.remove('visible');
                }
                
                // Mostra la schermata iniziale
                const startScreen = document.getElementById('startScreen');
                if (startScreen) {
                    startScreen.classList.remove('hidden');
                    startScreen.style.display = 'flex';
                }
                
                console.log('✅ Returned to main menu');
            }, 300);
        }
        
        // Mobile game over detection and overlay (legacy - mantieni per compatibilità)
        let mobileGameOverActive = false;
        
        function showMobileGameOver(score) {
            // Usa la nuova schermata unificata invece di quella legacy
            if (typeof Module !== 'undefined') {
                try {
                    const level = Module._getLevel ? Module._getLevel() : 1;
                    const lines = Module._getLines ? Module._getLines() : 0;
                    const gameTime = document.getElementById('gameTime')?.textContent?.replace(' (FINAL)', '') || '00:00';
                    
                    showNewGameOver(score, level, lines, gameTime);
                    return;
                } catch(e) {
                    console.log('Error getting game stats, using basic game over:', e);
                }
            }
            
            // Fallback alla schermata di base
            showNewGameOver(score);
        }
        
        function hideMobileGameOver() {
            hideNewGameOver();
        }
        
        // ==================== NUOVA GESTIONE GAME OVER UNIFICATA ==================== 
        
        // Variabili globali per la gestione del game over
        let gameOverData = {
            finalScore: 0,
            finalLevel: 1,
            finalLines: 0,
            finalTime: '00:00',
            previousRecord: 0,
            isNewRecord: false,
            gameStartTime: null,
            totalGameTime: 0
        };
        
        // Enhanced game over detection for mobile
        let lastKnownScore = 0;
        let gameOverCheckInterval;
        
        // Flag per evitare inizializzazioni multiple
        let gameOverMonitoringInitialized = false;
        
        function startGameOverMonitoring() {
            // Permetti re-inizializzazione se necessario
            if (gameOverCheckInterval) {
                console.log('� Clearing existing game over monitoring');
                clearInterval(gameOverCheckInterval);
                gameOverCheckInterval = null;
            }
            
            gameOverMonitoringInitialized = true; 
            console.log('✅ Starting game over monitoring');
            
            gameOverCheckInterval = setInterval(() => {
                if (typeof Module !== 'undefined' && Module._getScore && Module._isGameRunning) {
                    try {
                        const currentScore = Module._getScore();
                        const gameRunning = Module._isGameRunning();
                        
                        // Game over detected: not running and we had a score
                        if (!gameRunning && currentScore > 0 && !newGameOverActive && !mobileGameOverActive) {
                            console.log('🎮 Game over detected by monitoring:', {
                                score: currentScore,
                                gameRunning,
                                newGameOverActive,
                                mobileGameOverActive,
                                lastKnownScore
                            });
                            
                            // Usa la nuova schermata unificata
                            const currentLevel = Module._getLevel ? Module._getLevel() : 1;
                            const currentLines = Module._getLines ? Module._getLines() : 0;
                            const gameTime = document.getElementById('gameTime')?.textContent?.replace(' (FINAL)', '').replace(' (PAUSA)', '') || '00:00';
                            
                            showNewGameOver(currentScore, currentLevel, currentLines, gameTime);
                            lastKnownScore = currentScore;
                        }
                        
                        // Game restarted
                        if (gameRunning && currentScore === 0 && lastKnownScore > 0) {
                            console.log('🔄 Game restart detected - updating stats');
                            
                            // Nascondi qualsiasi schermata game over attiva
                            if (newGameOverActive) {
                                hideNewGameOver();
                            }
                            if (mobileGameOverActive) {
                                hideMobileGameOver();
                            }
                            
                            // Reset completo dello stato per il prossimo game over
                            lastKnownScore = 0;
                            newGameOverActive = false;
                            mobileGameOverActive = false;
                            
                            console.log('🔄 Game over states reset for new game');
                            
                            // Force immediate stats update
                            updateStatsFromCpp();
                            
                            // More frequent updates for first few seconds after restart
                            let restartUpdateCount = 0;
                            const restartUpdateInterval = setInterval(() => {
                                updateStatsFromCpp();
                                restartUpdateCount++;
                                if (restartUpdateCount >= 10) { // 10 updates = 1 second
                                    clearInterval(restartUpdateInterval);
                                }
                            }, 100); // Update every 100ms for 1 second
                        }
                    } catch(e) {
                        // Ignore errors accessing Module functions
                    }
                }
            }, 500); // Check every 500ms
        }
        
        // UNICO handler DOMContentLoaded consolidato per evitare inizializzazioni multiple
        document.addEventListener('DOMContentLoaded', () => {
            // ==================== NUOVA SCHERMATA GAME OVER ====================
            
            // Pulsanti della nuova schermata game over
            const gameOverRestartBtn = document.getElementById('gameOverRestartBtn');
            const gameOverMenuBtn = document.getElementById('gameOverMenuBtn');
            
            if (gameOverRestartBtn) {
                gameOverRestartBtn.addEventListener('click', () => {
                    console.log('🔄 Game over restart button clicked');
                    restartFromGameOver();
                });
            }
            
            if (gameOverMenuBtn) {
                gameOverMenuBtn.addEventListener('click', () => {
                    console.log('🏠 Game over menu button clicked');
                    returnToMainMenu();
                });
            }
            
            // ==================== ELEMENTI LEGACY ====================
            
            const pauseBtn = document.getElementById('mobilePauseBtn');
            const restartBtn = document.getElementById('mobileRestartBtn');
            const resumeBtn = document.getElementById('resumeGameBtn');
            const restartBtnMenu = document.getElementById('restartGameBtn');
            
            // Mobile game control buttons
            if (pauseBtn) {
                pauseBtn.addEventListener('click', () => {
                    console.log('Mobile pause clicked');
                    simulateKeyPress('Escape');
                    
                    // Toggle button text
                    if (pauseBtn.textContent.includes('Pausa')) {
                        pauseBtn.textContent = '▶️ Riprendi';
                    } else {
                        pauseBtn.textContent = '⏸️ Pausa';
                    }
                });
            }
            
            if (restartBtn) {
                restartBtn.addEventListener('click', () => {
                    console.log('Mobile restart clicked');
                    simulateKeyPress('Enter');
                    
                    // Reset pause button text
                    if (pauseBtn) {
                        pauseBtn.textContent = '⏸️ Pausa';
                    }
                });
            }
            
            // Mobile pause menu event listeners
            if (resumeBtn) {
                resumeBtn.addEventListener('click', () => {
                    console.log('📱 Resume clicked');
                    hideMobilePauseMenu();
                    
                    // Resume both JavaScript AND C++ game
                    setTimeout(() => {
                        if (isPaused) {
                            console.log('📱 Resuming JavaScript state first');
                            forceResume('mobile');
                            
                            // Now resume C++ game engine (only once!)
                            setTimeout(() => {
                                console.log('📱 Resuming C++ game engine');
                                simulateKeyPress('Escape', { restoreFocus: true });
                                
                                // Ensure body has focus for future menu interactions
                                setTimeout(() => {
                                    document.body.focus();
                                    console.log('🎯 Focus restored to body for mobile');
                                }, 100);
                            }, 50);
                        }
                    }, 100);
                });
            }
            
            // Desktop pause menu event listeners
            const desktopResumeBtn = document.getElementById('desktopResumeBtn');
            const desktopRestartBtn = document.getElementById('desktopRestartBtn');
            const desktopQuitBtn = document.getElementById('desktopQuitBtn');
            
            if (desktopResumeBtn) {
                desktopResumeBtn.addEventListener('click', () => {
                    console.log('🖥️ Desktop resume clicked');
                    hideDesktopPauseMenu();
                    
                    setTimeout(() => {
                        if (isPaused) {
                            forceResume('desktop');
                            
                            setTimeout(() => {
                                try {
                                    if (typeof Module !== 'undefined' && Module._isGamePaused && Module._isGamePaused()) {
                                        // Don't let canvas keep focus after resume
                                        simulateKeyPress('Escape', { restoreFocus: true });
                                        console.log('🎮 C++ game resumed from desktop menu');
                                        
                                        // Ensure document.body has focus for future ESC events
                                        setTimeout(() => {
                                            document.body.focus();
                                            console.log('🎯 Focus restored to body for future menu access');
                                        }, 100);
                                    }
                                } catch(e) {
                                    console.log('Error resuming C++ game:', e);
                                }
                            }, 50);
                        }
                    }, 100);
                });
            }
            
            if (desktopRestartBtn) {
                desktopRestartBtn.addEventListener('click', () => {
                    console.log('🖥️ Desktop restart clicked');
                    hideDesktopPauseMenu();
                    
                    setTimeout(() => {
                        resetGameInfo();
                        simulateKeyPress('Enter');
                        console.log('🎮 Game restarted from desktop menu');
                    }, 100);
                });
            }
            
            if (desktopQuitBtn) {
                desktopQuitBtn.addEventListener('click', () => {
                    console.log('🖥️ Desktop quit clicked');
                    hideDesktopPauseMenu();
                    
                    // Show confirmation dialog
                    if (confirm('Sei sicuro di voler uscire dal gioco? Il progresso andrà perso.')) {
                        // Stop the game and return to start screen
                        stopTimer();
                        
                        setTimeout(() => {
                            // Hide game container and show start screen
                            const gameContainer = document.querySelector('.game-container');
                            const startScreen = document.getElementById('startScreen');
                            
                            if (gameContainer) gameContainer.classList.remove('visible');
                            if (startScreen) {
                                startScreen.classList.remove('hidden');
                                startScreen.style.display = 'flex';
                            }
                            
                            // Reset game state
                            gameStartRequested = false;
                            console.log('🚪 Returned to start screen');
                        }, 500);
                    } else {
                        // User cancelled, show menu again
                        showDesktopPauseMenu();
                    }
                });
            }
            
            if (restartBtnMenu) {
                restartBtnMenu.addEventListener('click', () => {
                    console.log('📱 Restart clicked');
                    hideMobilePauseMenu();
                    
                    // Wait a moment then restart
                    setTimeout(() => {
                        resetGameInfo();
                        simulateKeyPress('Enter');
                        console.log('📱 Game restarted');
                    }, 100);
                });
            }
            
            // Close menus when clicking outside
            const mobileMenu = document.getElementById('mobilePauseMenu');
            const desktopMenu = document.getElementById('desktopPauseMenu');
            
            if (mobileMenu || desktopMenu) {
                document.addEventListener('click', (e) => {
                    // Mobile menu
                    if (mobileMenu && !mobileMenu.contains(e.target) && mobileMenu.classList.contains('active')) {
                        console.log('📱 Mobile menu closed by clicking outside');
                        hideMobilePauseMenu();
                        
                        // Resume game when closing menu
                        setTimeout(() => {
                            if (typeof Module !== 'undefined' && Module._isGamePaused) {
                                const isPaused = Module._isGamePaused();
                                if (isPaused) {
                                    simulateKeyPress('Escape');
                                    console.log('📱 Game auto-resumed');
                                }
                            }
                        }, 100);
                    }
                    
                    // Desktop menu
                    if (desktopMenu && !desktopMenu.querySelector('.desktop-pause-content').contains(e.target) && desktopMenu.classList.contains('active')) {
                        console.log('🖥️ Desktop menu closed by clicking outside');
                        hideDesktopPauseMenu();
                        
                        // Resume game when closing menu
                        setTimeout(() => {
                            if (isPaused) {
                                forceResume('desktop');
                                
                                setTimeout(() => {
                                    try {
                                        if (typeof Module !== 'undefined' && Module._isGamePaused && Module._isGamePaused()) {
                                            simulateKeyPress('Escape');
                                            console.log('🖥️ Game auto-resumed from outside click');
                                        }
                                    } catch(e) {
                                        console.log('Error resuming C++ game:', e);
                                    }
                                }, 50);
                            }
                        }, 100);
                    }
                });
            }
            
            // Inizializza il monitoring del game over per tutti i dispositivi
            console.log('🎮 Inizializzando sistema di monitoring game over...');
            setTimeout(() => {
                console.log('🎮 Avvio monitoring game over per tutti i dispositivi');
                startGameOverMonitoring();
            }, 2000);
        });
        
        // Precarica il gioco in background (senza avviarlo)
        setTimeout(() => {
            // Il gioco si caricherà ma non si avvierà automaticamente
        }, 100);
        
        // Mobile pause menu functions
        function showMobilePauseMenu() {
            console.log('📱 Long press detected - checking if menu already active');
            
            // Check if menu is already active
            const menu = document.getElementById('mobilePauseMenu');
            if (menu && menu.classList.contains('active')) {
                console.log('📱 Menu già attivo - ignorando long press');
                return;
            }
            
            // Show menu first
            if (menu) {
                mobilePauseActive = true; // Set flag to disable sync
                menu.classList.add('active');
                console.log('📱 Pause menu shown with overlay');
            }
            
            // Then pause both JavaScript AND C++ game
            setTimeout(() => {
                if (!isGameOver && !isPaused) {
                    console.log('📱 Pausing JavaScript state first');
                    forcePause('mobile');
                    
                    // Now pause C++ game engine (only once!)
                    setTimeout(() => {
                        console.log('📱 Pausing C++ game engine');
                        simulateKeyPress('Escape');
                    }, 50);
                } else {
                    console.log('📱 Game already paused or over, just showing menu');
                }
            }, 100);
        }
        
        function hideMobilePauseMenu() {
            const menu = document.getElementById('mobilePauseMenu');
            if (menu) {
                menu.classList.remove('active');
                console.log('📱 Pause menu hidden');
                
                // Re-enable sync after a short delay
                setTimeout(() => {
                    mobilePauseActive = false;
                    console.log('📱 Mobile pause system deactivated - sync re-enabled');
                }, 500);
            }
        }

        // ==================== CONTROLLI AUDIO ====================
        
        // Variabili globali per controllo audio
        let audioInitialized = false;
        
        // Inizializza controlli audio
        function initAudioControls() {
            if (audioInitialized) return;
            
            const volumeSlider = document.getElementById('volume-slider');
            const volumeValue = document.getElementById('volume-value');
            const muteButton = document.getElementById('mute-button');
            const muteIcon = muteButton.querySelector('.mute-icon');
            const muteText = muteButton.querySelector('.mute-text');
            
            if (!volumeSlider || !volumeValue || !muteButton) {
                console.log('Audio controls not found, retrying...');
                setTimeout(initAudioControls, 500);
                return;
            }
            
            console.log('🔊 Initializing audio controls...');
            
            // Carica impostazioni salvate
            const savedVolume = localStorage.getItem('tetris-volume');
            const savedMuted = localStorage.getItem('tetris-muted') === 'true';
            
            if (savedVolume !== null) {
                const volume = parseInt(savedVolume); // Valore 0-100
                volumeSlider.value = volume;
                volumeValue.textContent = volume;
                
                // Converti e applica il volume se il modulo è caricato
                if (typeof Module !== 'undefined' && Module._setVolume) {
                    const sdlVolume = Math.round((volume / 100) * 128);
                    Module._setVolume(sdlVolume);
                }
            }
            
            if (savedMuted) {
                muteButton.classList.add('muted');
                muteIcon.textContent = '🔇';
                muteText.textContent = 'Unmute';
                
                // Applica il mute se il modulo è caricato
                if (typeof Module !== 'undefined' && Module._muteAudio) {
                    Module._muteAudio(true);
                }
            }
            
            // Previeni propagazione eventi touch sui controlli audio
            const audioControlsContainer = document.querySelector('.audio-controls');
            if (audioControlsContainer) {
                audioControlsContainer.addEventListener('touchstart', function(e) {
                    e.stopPropagation();
                });
                audioControlsContainer.addEventListener('touchend', function(e) {
                    e.stopPropagation();
                });
                audioControlsContainer.addEventListener('touchmove', function(e) {
                    e.stopPropagation();
                });
                audioControlsContainer.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }
            
            // Event listener per il slider del volume
            volumeSlider.addEventListener('input', function(e) {
                e.stopPropagation();
                const volume = parseInt(this.value); // Valore 0-100
                volumeValue.textContent = volume;
                
                // Converti il volume da 0-100 a 0-128 per SDL
                const sdlVolume = Math.round((volume / 100) * 128);
                
                // Applica il volume al gioco
                if (typeof Module !== 'undefined' && Module._setVolume) {
                    try {
                        Module._setVolume(sdlVolume);
                        localStorage.setItem('tetris-volume', volume.toString()); // Salva il valore 0-100
                        console.log('🔊 Volume set to:', volume + '% (SDL: ' + sdlVolume + ')');
                    } catch (e) {
                        console.error('Error setting volume:', e);
                    }
                }
                
                // Se il volume è > 0 e l'audio era mutato, togli il mute
                if (volume > 0 && muteButton.classList.contains('muted')) {
                    muteButton.classList.remove('muted');
                    muteIcon.textContent = '🔊';
                    muteText.textContent = 'Mute';
                    
                    if (typeof Module !== 'undefined' && Module._muteAudio) {
                        Module._muteAudio(false);
                        localStorage.setItem('tetris-muted', 'false');
                    }
                }
            });
            
            // Previeni eventi touch specifici per il volume slider
            volumeSlider.addEventListener('touchstart', function(e) {
                e.stopPropagation();
            });
            volumeSlider.addEventListener('touchend', function(e) {
                e.stopPropagation();
            });
            volumeSlider.addEventListener('touchmove', function(e) {
                e.stopPropagation();
            });
            
            // Event listener per il pulsante mute
            muteButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const isMuted = this.classList.contains('muted');
                
                if (isMuted) {
                    // Unmute
                    this.classList.remove('muted');
                    muteIcon.textContent = '🔊';
                    muteText.textContent = 'Mute';
                    
                    if (typeof Module !== 'undefined' && Module._muteAudio) {
                        try {
                            Module._muteAudio(false);
                            localStorage.setItem('tetris-muted', 'false');
                            console.log('🔊 Audio unmuted');
                        } catch (e) {
                            console.error('Error unmuting audio:', e);
                        }
                    }
                } else {
                    // Mute
                    this.classList.add('muted');
                    muteIcon.textContent = '🔇';
                    muteText.textContent = 'Unmute';
                    
                    if (typeof Module !== 'undefined' && Module._muteAudio) {
                        try {
                            Module._muteAudio(true);
                            localStorage.setItem('tetris-muted', 'true');
                            console.log('🔇 Audio muted');
                        } catch (e) {
                            console.error('Error muting audio:', e);
                        }
                    }
                }
            });
            
            audioInitialized = true;
            console.log('🔊 Audio controls initialized successfully');
        }
        
        // Inizializza i controlli audio quando il DOM è pronto
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(initAudioControls, 1000);
        });
        
        // Riprova l'inizializzazione quando il modulo Emscripten è caricato
        window.addEventListener('load', function() {
            setTimeout(initAudioControls, 2000);
        });

        
    </script>
    
    <!-- Script del gioco generato da Emscripten -->
    <script async src="tetris.js"></script>
</body>
</html>