<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=3.0, user-scalable=yes">
    <title>üéÆ Tetris Classic - Gioca Online Gratis</title>
    <meta name="description" content="Gioca al classico Tetris online gratis! Tetris moderno in WebAssembly con grafica SDL2, audio e controlli perfetti.">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <meta property="og:title" content="üéÆ Tetris Classic - Gioca Online Gratis">
    <meta property="og:description" content="Il leggendario puzzle game Tetris ora disponibile gratis nel browser!">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a40 50%, #2d1b69 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Particelle animate di sfondo */
        .bg-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #64ffda;
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
            opacity: 0.6;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }

        /* Header */
        .header {
            text-align: center;
            padding: 2rem 1rem;
            position: relative;
            z-index: 10;
        }

        .title {
            font-family: 'Orbitron', monospace;
            font-size: clamp(2.5rem, 8vw, 5rem);
            font-weight: 900;
            background: linear-gradient(45deg, #64ffda, #00bcd4, #2196f3, #9c27b0);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(100, 255, 218, 0.5);
            margin-bottom: 0.5rem;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            font-size: 1.2rem;
            color: #b0bec5;
            margin-bottom: 1rem;
            font-weight: 300;
        }

        .game-info {
            font-size: 0.9rem;
            color: #78909c;
            max-width: 600px;
            margin: 0 auto 2rem;
            line-height: 1.6;
        }

        /* Container del gioco */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 1rem;
            position: relative;
            z-index: 5;
        }

        .game-wrapper {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            margin-bottom: 2rem;
        }

        .game-wrapper::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #64ffda, #2196f3, #9c27b0, #64ffda);
            border-radius: 22px;
            z-index: -1;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        /* Layout del gioco con pannelli laterali */
        .game-layout {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 2rem;
            min-height: 500px;
        }

        .left-stats, .right-info {
            flex: 0 0 200px;
            display: flex;
            flex-direction: column;
        }

        .game-canvas {
            flex: 0 0 auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        /* Pannelli statistiche */
        .stats-panel, .info-panel {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            padding: 1.5rem;
            border: 2px solid rgba(100, 255, 218, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: sticky;
            top: 2rem;
        }

        .stats-title, .info-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: #64ffda;
            text-align: center;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
        }

        .stat-item, .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 1.2rem;
            padding: 0.8rem;
            background: rgba(100, 255, 218, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            transition: all 0.3s ease;
        }

        .stat-item:hover, .info-item:hover {
            background: rgba(100, 255, 218, 0.2);
            border-color: rgba(100, 255, 218, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(100, 255, 218, 0.2);
        }

        .stat-label, .info-label {
            font-size: 0.9rem;
            color: #b0bec5;
            margin-bottom: 0.5rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value, .info-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.4rem;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 0 8px rgba(100, 255, 218, 0.6);
            background: linear-gradient(45deg, #64ffda, #00bcd4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Canvas styling */
        #canvas {
            border-radius: 12px;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            background: #000;
            display: block;
            margin: 0 auto;

            /* Default canvas sizing: let JS set internal buffer but allow CSS scaling */
            width: auto;      /* preserve default on desktop */
            height: auto;
            max-width: 100%;  /* never overflow its container */
            touch-action: none; /* prevent double interactions on mobile */
        }

        /* Responsive canvas wrapper to control visual scaling */
        .game-canvas {
            flex: 0 0 auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
        }

        /* Controlli */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin: 1.5rem 0;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(100, 255, 218, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 0.7rem;
            padding: 0.8rem 1.2rem;
            background: rgba(100, 255, 218, 0.15);
            border-radius: 10px;
            border: 2px solid rgba(100, 255, 218, 0.4);
            transition: all 0.3s ease;
            min-width: 120px;
            justify-content: center;
        }

        .control-item:hover {
            background: rgba(100, 255, 218, 0.25);
            border-color: rgba(100, 255, 218, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(100, 255, 218, 0.2);
        }

        .control-key {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #ffffff;
            background: linear-gradient(135deg, #64ffda, #2196f3);
            padding: 0.3rem 0.7rem;
            border-radius: 6px;
            font-size: 0.9rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 2px 8px rgba(100, 255, 218, 0.3);
            min-width: 35px;
            text-align: center;
        }

        .control-desc {
            color: #ffffff;
            font-size: 1rem;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
        }

        /* Loading personalizzato */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 35, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .tetris-loader {
            display: flex;
            gap: 4px;
            margin-bottom: 2rem;
        }

        .tetris-block {
            width: 20px;
            height: 20px;
            border-radius: 2px;
            animation: tetrisFall 1.5s ease-in-out infinite;
        }

        .tetris-block:nth-child(1) { background: #64ffda; animation-delay: 0s; }
        .tetris-block:nth-child(2) { background: #2196f3; animation-delay: 0.2s; }
        .tetris-block:nth-child(3) { background: #9c27b0; animation-delay: 0.4s; }
        .tetris-block:nth-child(4) { background: #ff5722; animation-delay: 0.6s; }

        @keyframes tetrisFall {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(20px); }
        }

        .loading-text {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: #64ffda;
            margin-bottom: 1rem;
        }

        .loading-progress {
            color: #78909c;
            font-size: 1rem;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 2rem 1rem;
            color: #546e7a;
            font-size: 0.9rem;
        }

        .footer a {
            color: #64ffda;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .footer a:hover {
            color: #00bcd4;
        }

        /* Mobile Optimization */
        @media (max-width: 768px) {
            .game-wrapper {
                padding: 1rem;
                margin: 0 0.5rem 1rem;
            }

            /* Remove minimum height forcing overflow on small screens */
            .game-layout {
                min-height: auto;
            }

            /* Scale canvas so it always fits into the viewport
               - max-width limits visual width
               - max-height prevents it from exceeding available vertical space */
            .game-canvas {
                width: 100%;
                max-width: 90vw;
            }

            #canvas {
                /* Let the canvas scale to fit the screen while keeping aspect ratio */
                width: 100% !important;
                height: auto !important;
                max-width: 520px; /* reasonable upper bound for tablets */
                max-height: calc(100vh - 220px); /* reserve space for header/controls/footer */
            }

            .game-layout {
                flex-direction: column;
                gap: 1rem;
                align-items: center;
            }

            .left-stats, .right-info {
                flex: none;
                width: 100%;
                max-width: 400px;
            }

            .stats-panel, .info-panel {
                position: static;
                padding: 1rem;
            }

            .stat-item, .info-item {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.8rem;
            }

            .stat-label, .info-label {
                margin-bottom: 0;
                text-align: left;
            }

            .stat-value, .info-value {
                font-size: 1.2rem;
                text-align: right;
            }
            
            .controls {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 0.8rem;
                padding: 1rem;
            }
            
            .control-item {
                justify-content: center;
                padding: 1rem;
                min-width: auto;
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }
            
            .control-key {
                font-size: 1.1rem;
                padding: 0.5rem 0.8rem;
                min-width: 50px;
            }
            
            .control-desc {
                font-size: 0.9rem;
            }
            
            .start-title {
                font-size: clamp(2rem, 12vw, 4rem);
            }
            
            .play-button {
                padding: 1.2rem 3rem;
                font-size: 1.3rem;
            }
            
            .game-info {
                font-size: 1rem;
                padding: 0 1rem;
            }
        }
        
        /* Extra small screens */
        @media (max-width: 480px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .control-item {
                flex-direction: row;
                justify-content: space-between;
                padding: 1rem 1.5rem;
            }
            
            .header {
                padding: 1rem;
            }
            
            .game-wrapper {
                padding: 0.5rem;
            }

            .left-stats, .right-info {
                max-width: none;
                width: 95%;
            }

            .stats-panel, .info-panel {
                padding: 0.8rem;
            }

            .stats-title, .info-title {
                font-size: 1rem;
                margin-bottom: 1rem;
            }

            .stat-value, .info-value {
                font-size: 1.1rem;
            }

            .game-layout {
                gap: 0.8rem;
            }
        }

        /* Landscape orientation adjustments */
        @media (max-width: 768px) and (orientation: landscape) {
            .game-layout {
                flex-direction: row;
                gap: 1rem;
            }

            .left-stats, .right-info {
                flex: 0 0 150px;
                width: auto;
            }

            .stats-panel, .info-panel {
                padding: 0.8rem;
            }

            .stat-item, .info-item {
                flex-direction: column;
                margin-bottom: 0.6rem;
                padding: 0.5rem;
            }

            .stat-value, .info-value {
                font-size: 1rem;
            }
        }

        /* Schermata iniziale */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a40 50%, #2d1b69 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.8s ease-in-out, transform 0.8s ease-in-out;
        }

        .start-screen.hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }

        .start-content {
            text-align: center;
            max-width: 600px;
            padding: 2rem;
        }

        .start-title {
            font-family: 'Orbitron', monospace;
            font-size: clamp(3rem, 10vw, 6rem);
            font-weight: 900;
            background: linear-gradient(45deg, #64ffda, #00bcd4, #2196f3, #9c27b0);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 50px rgba(100, 255, 218, 0.5);
            margin-bottom: 1rem;
        }

        .start-subtitle {
            font-size: 1.5rem;
            color: #b0bec5;
            margin-bottom: 2rem;
            font-weight: 300;
        }

        .play-button {
            background: linear-gradient(45deg, #64ffda, #2196f3);
            border: none;
            padding: 1.5rem 4rem;
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: #0f0f23;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 10px 30px rgba(100, 255, 218, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .play-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .play-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 
                0 20px 40px rgba(100, 255, 218, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.2);
        }

        .play-button:hover::before {
            left: 100%;
        }

        .play-button:active {
            transform: translateY(-2px) scale(1.02);
        }

        .start-instructions {
            margin-top: 2rem;
            color: #78909c;
            font-size: 1rem;
            line-height: 1.6;
        }

        .preview-blocks {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 2rem 0;
            opacity: 0.7;
        }

        .preview-block {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            animation: blockPulse 2s ease-in-out infinite;
        }

        .preview-block:nth-child(1) { background: #64ffda; animation-delay: 0s; }
        .preview-block:nth-child(2) { background: #2196f3; animation-delay: 0.3s; }
        .preview-block:nth-child(3) { background: #9c27b0; animation-delay: 0.6s; }
        .preview-block:nth-child(4) { background: #ff5722; animation-delay: 0.9s; }
        .preview-block:nth-child(5) { background: #4caf50; animation-delay: 1.2s; }

        @keyframes blockPulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        /* Nascondi il gioco inizialmente */
        .game-container {
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.8s ease-in-out;
            pointer-events: none;
        }

        .game-container.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        /* Mobile Instructions */
        .mobile-instructions {
            display: none;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 16px;
            padding: 1.5rem;
            margin: 1rem 0;
            border: 2px solid rgba(100, 255, 218, 0.3);
            backdrop-filter: blur(10px);
        }

        .mobile-instructions h3 {
            color: #64ffda;
            font-family: 'Orbitron', monospace;
            text-align: center;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .touch-controls {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .touch-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem;
            background: rgba(100, 255, 218, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }

        .touch-gesture {
            font-size: 1.1rem;
            font-weight: 600;
            color: #64ffda;
        }

        .touch-action {
            color: #ffffff;
            font-weight: 500;
        }

        .mobile-only {
            display: none;
        }

        /* Mobile game control help text and menu */
        .mobile-game-controls {
            display: none;
            justify-content: center;
            margin-top: 1rem;
            padding: 0 1rem;
        }
        
        .mobile-help-text {
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            color: rgba(100, 255, 218, 0.8);
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
        
        /* Mobile Pause Menu */
        .mobile-pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .mobile-pause-content {
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid #64ffda;
            border-radius: 20px;
            padding: 2rem;
            min-width: 250px;
            text-align: center;
        }
        
        .mobile-pause-menu.active {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }
        
        .mobile-pause-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: #64ffda;
            text-align: center;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px #64ffda;
        }
        
        .mobile-pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .mobile-btn {
            background: linear-gradient(135deg, #64ffda, #2196f3);
            border: none;
            padding: 0.8rem 1.5rem;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            font-weight: 600;
            color: #0f0f23;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.3);
            min-width: 120px;
        }

        .mobile-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(100, 255, 218, 0.4);
        }

        .mobile-btn:active {
            transform: translateY(0);
        }

        .pause-btn {
            background: linear-gradient(135deg, #ffb74d, #ff9800);
        }

        .restart-btn {
            background: linear-gradient(135deg, #81c784, #4caf50);
        }

        /* Mobile Game Over Overlay */
        .mobile-gameover-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 35, 0.98);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(15px);
        }
        
        /* Hide canvas on mobile when game over overlay is active */
        @media (max-width: 768px) {
            .mobile-gameover-overlay.active ~ * #canvas {
                visibility: hidden !important;
            }
        }

        .mobile-gameover-content {
            text-align: center;
            padding: 2rem;
            max-width: 90%;
        }

        .mobile-gameover-title {
            font-family: 'Orbitron', monospace;
            font-size: 3rem;
            font-weight: 900;
            color: #ff5722;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(255, 87, 34, 0.5);
        }

        .mobile-gameover-score {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: #64ffda;
            margin-bottom: 2rem;
        }

        .mobile-gameover-instruction {
            font-size: 1.2rem;
            color: #ffffff;
            margin-bottom: 1rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Desktop-only elements (hidden on mobile) */
        .desktop-only {
            display: block;
        }

        /* Show mobile elements on small screens */
        @media (max-width: 768px) {
            .mobile-instructions {
                display: block;
            }
            
            .mobile-only {
                display: flex;
            }
            
            .desktop-only {
                display: none !important;
            }
            
            .mobile-game-controls {
                display: flex !important;
            }
            
            .mobile-game-controls {
                display: flex !important;
            }
            
            .mobile-game-controls {
                display: flex !important;
            }
        }

        /* Nascondi elementi Emscripten originali */
        #emscripten_logo,
        #spinner,
        #progress,
        #controls,
        #output {
            display: none !important;
        }

        #status {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Particelle animate di sfondo -->
    <div class="bg-particles">
        <div class="particle" style="left: 10%; animation-delay: 0s;"></div>
        <div class="particle" style="left: 20%; animation-delay: 1s;"></div>
        <div class="particle" style="left: 30%; animation-delay: 2s;"></div>
        <div class="particle" style="left: 40%; animation-delay: 3s;"></div>
        <div class="particle" style="left: 50%; animation-delay: 4s;"></div>
        <div class="particle" style="left: 60%; animation-delay: 5s;"></div>
        <div class="particle" style="left: 70%; animation-delay: 2.5s;"></div>
        <div class="particle" style="left: 80%; animation-delay: 1.5s;"></div>
        <div class="particle" style="left: 90%; animation-delay: 3.5s;"></div>
    </div>

    <!-- Schermata iniziale con pulsante PLAY -->
    <div class="start-screen" id="startScreen">
        <div class="start-content">
            <h1 class="start-title">üéÆ TETRIS</h1>
            <p class="start-subtitle">Il Leggendario Puzzle Game</p>
            
            <div class="preview-blocks">
                <div class="preview-block"></div>
                <div class="preview-block"></div>
                <div class="preview-block"></div>
                <div class="preview-block"></div>
                <div class="preview-block"></div>
            </div>
            
            <button class="play-button" id="playButton">
                ‚ñ∂Ô∏è GIOCA ORA
            </button>
            
            <div class="start-instructions">
                <p><strong>Come si gioca:</strong></p>
                <p>Usa le frecce per muovere e ruotare i blocchi<br>
                Completa le righe per guadagnare punti<br>
                Pi√π veloce vai, pi√π punti ottieni!</p>
            </div>
        </div>
    </div>

    <!-- Mobile Game Over Overlay -->
    <div class="mobile-gameover-overlay" id="mobileGameOverOverlay">
        <div class="mobile-gameover-content">
            <div class="mobile-gameover-title">GAME OVER</div>
            <div class="mobile-gameover-score" id="mobileGameOverScore">Punteggio: 0</div>
            <div class="mobile-gameover-instruction">üëÜ Tap per riavviare</div>
        </div>
    </div>

    <!-- Mobile Pause Menu -->
    <div class="mobile-pause-menu" id="mobilePauseMenu">
        <div class="mobile-pause-content">
            <div class="mobile-pause-title">‚è∏Ô∏è PAUSA</div>
            <div class="mobile-pause-buttons">
                <button class="mobile-btn" id="resumeGameBtn">‚ñ∂Ô∏è Riprendi</button>
                <button class="mobile-btn" id="restartGameBtn">üîÑ Ricomincia</button>
            </div>
        </div>
    </div>

    <!-- Mobile Game Over Overlay -->
    <div class="mobile-gameover-overlay" id="mobileGameOverOverlay">
        <div class="mobile-gameover-content">
            <div class="mobile-gameover-title">GAME OVER</div>
            <div class="mobile-gameover-score" id="mobileGameOverScore">Punteggio: 0</div>
            <div class="mobile-gameover-instruction">üëÜ Tap per riavviare</div>
        </div>
    </div>

    <!-- Loading overlay personalizzato -->
    <div class="loading-overlay" id="customLoading">
        <div class="tetris-loader">
            <div class="tetris-block"></div>
            <div class="tetris-block"></div>
            <div class="tetris-block"></div>
            <div class="tetris-block"></div>
        </div>
        <div class="loading-text">TETRIS</div>
        <div class="loading-progress" id="loadingProgress">Caricamento del gioco...</div>
    </div>

    <!-- Header -->
    <div class="header">
        <h1 class="title">üéÆ TETRIS</h1>
        <p class="subtitle">Il Classico Puzzle Game</p>
        <div class="game-info">
            Gioca al leggendario Tetris direttamente nel browser! Versione moderna compilata in WebAssembly 
            con grafica SDL2, audio coinvolgente e controlli reattivi. Nessun download richiesto.
        </div>
    </div>

    <!-- Container del gioco -->
    <div class="game-container">
        <div class="game-wrapper">
            <!-- Layout con statistiche sui lati -->
            <div class="game-layout">
                <!-- Statistiche a sinistra -->
                <div class="left-stats">
                    <div class="stats-panel">
                        <h3 class="stats-title">üìä STATS</h3>
                        <div class="stat-item">
                            <span class="stat-label">Punteggio</span>
                            <span class="stat-value" id="scoreDisplay">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Livello</span>
                            <span class="stat-value" id="levelDisplay">1</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Linee</span>
                            <span class="stat-value" id="linesDisplay">0</span>
                        </div>
                    </div>
                </div>

                <!-- Canvas del gioco al centro -->
                <div class="game-canvas">
                    <canvas id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
                </div>

                <!-- Info aggiuntive a destra -->
                <div class="right-info">
                    <div class="info-panel">
                        <h3 class="info-title">üéÆ INFO</h3>
                        <div class="info-item">
                            <span class="info-label">Stato</span>
                            <span class="info-value" id="gameState">Pronto</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Tempo</span>
                            <span class="info-value" id="gameTime">00:00</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Record</span>
                            <span class="info-value" id="highScore">0</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Controlli -->
            <div class="controls desktop-only">
                <div class="control-item">
                    <div class="control-key">‚Üê ‚Üí</div>
                    <div class="control-desc">Movimento</div>
                </div>
                <div class="control-item">
                    <div class="control-key">‚Üë</div>
                    <div class="control-desc">Ruota</div>
                </div>
                <div class="control-item">
                    <div class="control-key">‚Üì</div>
                    <div class="control-desc">Caduta veloce</div>
                </div>
                <div class="control-item">
                    <div class="control-key">ESC</div>
                    <div class="control-desc">Pausa</div>
                </div>
                <div class="control-item">
                    <div class="control-key">INVIO</div>
                    <div class="control-desc">Ricomincia</div>
                </div>
                <div class="control-item mobile-only">
                    <div class="control-key">üì±</div>
                    <div class="control-desc">Touch/Swipe</div>
                </div>
            </div>
            
            <!-- Istruzioni Mobile -->
            <div class="mobile-instructions">
                <h3>üì± Controlli Touch</h3>
                <div class="touch-controls">
                    <div class="touch-item">
                        <span class="touch-gesture">üëÜ Tap</span>
                        <span class="touch-action">Ruota pezzo</span>
                    </div>
                    <div class="touch-item">
                        <span class="touch-gesture">üëà üëâ Swipe</span>
                        <span class="touch-action">Muovi lateralmente</span>
                    </div>
                    <div class="touch-item">
                        <span class="touch-gesture">üëá Swipe gi√π</span>
                        <span class="touch-action">Caduta veloce</span>
                    </div>
                </div>
                
                <!-- Mobile Long Press Help Text -->
                <div class="mobile-game-controls">
                    <div class="mobile-help-text">Tieni premuto per menu pausa</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <div class="footer">
        <p>Creato con ‚ù§Ô∏è utilizzando C++, SDL2 e WebAssembly</p>
        <p>¬© 2025 - <a href="https://github.com/gianfrizio/Tetris" target="_blank">Codice sorgente su GitHub</a></p>
    </div>

    <!-- Script Emscripten (modificato) -->
    <script>
    // Elementi DOM
    const startScreen = document.getElementById('startScreen');
    const playButton = document.getElementById('playButton');
    const customLoading = document.getElementById('customLoading');
    const loadingProgress = document.getElementById('loadingProgress');
    const gameContainer = document.querySelector('.game-container');

    let gameReady = false;
    let gameStarted = false;
    let gameStartRequested = false;
        
        // Nascondi il loading inizialmente
        customLoading.style.display = 'none';
        
        // Ensure Module is available on the global object for Emscripten compatibility
        globalThis.Module = globalThis.Module || {};
        Object.assign(globalThis.Module, {
            canvas: document.getElementById('canvas'),

            print: function(...args) {
                console.log(...args);
            },

            setStatus: function(text) {
                // Carica il gioco silenziosamente in background
                if (text) {
                    console.log('Game status:', text);
                    if (text.includes('complete') || !text) {
                        gameReady = true;
                        console.log('Game is ready!');
                    }
                } else {
                    gameReady = true;
                    console.log('Game ready (no status)');
                }
                
                // Se il gioco √® stato avviato dall'utente, mostra i progressi
                if (gameStarted) {
                    if (text && text.includes('Downloading')) {
                        loadingProgress.textContent = 'Download del gioco...';
                    } else if (text && text.includes('Preparing')) {
                        loadingProgress.textContent = 'Preparazione...';
                    } else {
                        loadingProgress.textContent = 'Avvio del gioco...';
                    }
                }
            },
            
            totalDependencies: 0,
            monitorRunDependencies: function(left) {
                this.totalDependencies = Math.max(this.totalDependencies, left);
                console.log('Dependencies left:', left);
                if (left === 0) {
                    gameReady = true;
                }
            }
        });

        // Gestione pulsante PLAY
        playButton.addEventListener('click', function() {
            gameStarted = true;
            gameStartRequested = true;
            
            // Nascondi schermata iniziale
            startScreen.classList.add('hidden');
            
            // Mostra loading
            customLoading.style.display = 'flex';
            customLoading.style.opacity = '1';
            loadingProgress.textContent = 'Avvio del gioco...';
            
            setTimeout(() => {
                startScreen.style.display = 'none';
                
                // Aspetta che il gioco sia caricato, poi avvialo
                setTimeout(() => {
                    customLoading.style.opacity = '0';
                    setTimeout(() => {
                        customLoading.style.display = 'none';
                        gameContainer.classList.add('visible');
                        
                        // Fit canvas to viewport
                        fitCanvasToViewport();
                        
                        // Avvia il gioco chiamando la funzione C++
                        let gameStarted = false;
                        
                        function tryStartGame() {
                            if (gameStarted) return; // Evita di avviare il gioco pi√π volte
                            
                            try {
                                if (typeof Module !== 'undefined' && Module._startTetrisGame) {
                                    Module._startTetrisGame();
                                    gameStarted = true;
                                    console.log('Game started via C++ function!');
                                    
                                    // Avvia il timer JavaScript
                                    window.startGameTimer();
                                    
                                    // Avvia l'aggiornamento delle statistiche
                                    startStatsUpdater();
                                } else {
                                    console.log('Module not ready yet, retrying...');
                                    // Riprova una sola volta dopo un po'
                                    setTimeout(() => {
                                        if (!gameStarted && typeof Module !== 'undefined' && Module._startTetrisGame) {
                                            Module._startTetrisGame();
                                            gameStarted = true;
                                            console.log('Game started via C++ function (retry)!');
                                            
                                            // Avvia il timer JavaScript
                                            window.startGameTimer();
                                            
                                            // Avvia l'aggiornamento delle statistiche
                                            startStatsUpdater();
                                        }
                                    }, 500);
                                }
                            } catch(e) {
                                console.error('Error starting game:', e);
                            }
                        }
                        
                        tryStartGame();
                    }, 500);
                }, 1000);
            }, 800);
        });

        // Gestione errori personalizzata
        window.onerror = function(event) {
            if (gameStarted) {
                loadingProgress.textContent = 'Errore nel caricamento del gioco';
                console.error('Game loading error:', event);
            }
        };
        
        // Ferma l'aggiornamento statistiche quando la pagina viene chiusa
        window.addEventListener('beforeunload', function() {
            stopStatsUpdater();
        });
        
        // Effetto di transizione per il loading
        customLoading.style.transition = 'opacity 0.5s ease-in-out';
        
        // Sistema di aggiornamento statistiche del gioco
        let statsUpdateInterval;
        let lastScore = 0;
        let lastLevel = 1;
        let lastLines = 0;
        let gameStartTimeReal = null;
        let highScore = localStorage.getItem('tetris-high-score') || 0;
        let isGameOver = false;
        let gameEndTime = null;
        let lastRunningState = true;
        let gameStoppedTime = null;
        let lastScoreCheck = 0;
        let scoreStuckCount = 0;
        let totalPausedTime = 0;
        let pauseStartTime = null;
        let lastGameRunningState = true;
        let isManuallyPaused = false;
        let isTimerRunning = true;
        let lastScoreChangeTime = Date.now();
        
        function startStatsUpdater() {
            console.log('Starting stats updater...');
            
        // Reset dello stato del gioco
        isGameOver = false;
        gameEndTime = null;
        lastRunningState = true;
        gameStoppedTime = null;
        lastScoreCheck = 0;
        scoreStuckCount = 0;
        totalPausedTime = 0;
        pauseStartTime = null;
        lastGameRunningState = true;
        isManuallyPaused = false;
        isTimerRunning = true;
        lastScoreChangeTime = Date.now();
        
        console.log('üîÑ Game state reset for new game');            // Inizializza il tempo di gioco
            gameStartTimeReal = Date.now();
            
            // Imposta il record salvato
            document.getElementById('highScore').textContent = parseInt(highScore).toLocaleString();
            
            // La musica √® gestita dal codice C++ del gioco
            
            // Aggiorna le statistiche ogni 100ms
            statsUpdateInterval = setInterval(updateGameStats, 100);
        }
        
        function updateGameStats() {
            try {
                // PRIMA: Aggiorna il tempo di gioco (SENZA SINCRONIZZAZIONE C++ CHE ROMPE)
                updateGameTime();
                
                // TERZA: Aggiorna le statistiche del C++
                if (typeof Module !== 'undefined') {
                    try {
                        const score = Module._getScore();
                        const level = Module._getLevel();
                        const lines = Module._getLines();
                        
                        // Aggiorna il punteggio solo se cambiato
                        if (score !== lastScore) {
                            lastScore = score;
                            lastScoreChangeTime = Date.now();
                            
                            // Aggiorna record se necessario
                            if (score > highScore) {
                                highScore = score;
                                localStorage.setItem('tetris-high-score', highScore);
                            }
                        }
                        
                        // Aggiorna tutti i display
                        const scoreElement = document.getElementById('scoreDisplay');
                        const levelElement = document.getElementById('levelDisplay');
                        const linesElement = document.getElementById('linesDisplay');
                        const highScoreElement = document.getElementById('highScore');
                        
                        if (scoreElement) scoreElement.textContent = score.toLocaleString();
                        if (levelElement) levelElement.textContent = level;
                        if (linesElement) linesElement.textContent = lines;
                        if (highScoreElement) highScoreElement.textContent = parseInt(highScore).toLocaleString();
                        
                    } catch (error) {
                        // Ignora errori di accesso al Module
                    }
                }
                
                // QUARTA: Sincronizza con lo stato del C++
                syncGameStateWithCpp();
                
                // QUINTA: Aggiorna il display dello stato
                updateGameState();
                
            } catch(e) {
                console.error('Error updating stats:', e);
            }
        }
        
        // Nuova funzione per sincronizzare lo stato JavaScript con il C++
        function syncWithCppState() {
            if (typeof Module === 'undefined') return;
            
            try {
                const cppRunning = Module._isGameRunning ? Module._isGameRunning() : false;
                const cppPaused = Module._isGamePaused ? Module._isGamePaused() : false;
                
                // Se il C++ dice che il gioco √® in pausa ma JavaScript no
                if (cppPaused && !isPaused && !isGameOver) {
                    console.log('üéÆ C++ is paused, syncing JavaScript');
                    isPaused = true;
                    isTimerRunning = false;
                    if (!pauseStartTime) {
                        pauseStartTime = Date.now();
                    }
                    
                    const gameStateElement = document.getElementById('gameState');
                    if (gameStateElement) {
                        gameStateElement.textContent = 'In pausa';
                        gameStateElement.style.color = '#ffa726';
                    }
                }
                // Se il C++ dice che il gioco non √® in pausa ma JavaScript s√¨
                else if (!cppPaused && isPaused && cppRunning) {
                    console.log('üéÆ C++ resumed, syncing JavaScript');
                    if (pauseStartTime) {
                        totalPausedTime += Date.now() - pauseStartTime;
                        pauseStartTime = null;
                    }
                    isPaused = false;
                    isTimerRunning = true;
                    
                    const gameStateElement = document.getElementById('gameState');
                    if (gameStateElement) {
                        gameStateElement.textContent = 'In corso';
                        gameStateElement.style.color = '';
                    }
                }
                // Se il C++ non √® running e non √® paused, probabilmente √® game over
                else if (!cppRunning && !cppPaused && gameStartTimeReal && !isGameOver) {
                    console.log('üéÆ C++ game over detected, syncing JavaScript');
                    isGameOver = true;
                    isTimerRunning = false;
                    isPaused = false;
                    gameEndTime = Date.now();
                    
                    const gameStateElement = document.getElementById('gameState');
                    if (gameStateElement) {
                        gameStateElement.textContent = 'Game Over';
                        gameStateElement.style.color = '#ff5722';
                    }
                }
                
            } catch(e) {
                // Ignora errori di sincronizzazione
            }
        }
        
        function checkForGameOver() {
            if (isGameOver || !isTimerRunning) return; // Se gi√† in game over o in pausa, non controllare
            
            // Metodo 1: Rileva se il punteggio non cambia per molto tempo e il gioco sembra fermo
            const currentTime = Date.now();
            
            // Se il punteggio √® cambiato, aggiorna il timestamp
            if (lastScore !== lastScoreCheck) {
                lastScoreChangeTime = currentTime;
                lastScoreCheck = lastScore;
                scoreStuckCount = 0;
                return;
            }
            
            // Se il punteggio √® > 0 e non cambia da pi√π di 3 secondi, √® game over
            if (lastScore > 0 && (currentTime - lastScoreChangeTime) > 3000) {
                console.log('ÔøΩ GAME OVER AUTO-DETECTED! Score stuck for 3+ seconds with score:', lastScore);
                stopTimer();
                return;
            }
            
            // Metodo alternativo: conta i cicli di controllo
            scoreStuckCount++;
            if (lastScore > 0 && scoreStuckCount > 30) { // 30 * 100ms = 3 secondi
                console.log('üíÄ GAME OVER AUTO-DETECTED! Score stuck counter reached:', scoreStuckCount);
                stopTimer();
            }
            
            // Metodo 2: Rileva pattern di game over tramite eventi DOM o canvas
            // Questo potrebbe essere migliorato osservando il canvas per messaggi di game over
            try {
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    // Qui potremmo analizzare il contenuto del canvas per cercare testo "GAME OVER"
                    // Per ora usiamo solo il metodo del punteggio bloccato
                }
            } catch(e) {
                // Ignora errori di analisi canvas
            }
        }
        
        function updateGameTime() {
            const gameTimeElement = document.getElementById('gameTime');
            
            if (!gameTimeElement || !gameStartTimeReal) return;
            
            let elapsed, minutes, seconds, timeString;
            
            if (isGameOver) {
                // Game over - usa tempo fisso
                if (gameEndTime) {
                    elapsed = Math.floor((gameEndTime - gameStartTimeReal - totalPausedTime) / 1000);
                } else {
                    elapsed = Math.floor((Date.now() - gameStartTimeReal - totalPausedTime) / 1000);
                }
                minutes = Math.floor(elapsed / 60);
                seconds = elapsed % 60;
                timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                gameTimeElement.textContent = timeString + ' (FINAL)';
                gameTimeElement.style.color = '#ff5722';
                return;
            }
            
            if (isTimerRunning) {
                // Timer attivo - calcola tempo corrente
                const currentTime = isPaused ? pauseStartTime : Date.now();
                elapsed = Math.floor((currentTime - gameStartTimeReal - totalPausedTime) / 1000);
                minutes = Math.floor(elapsed / 60);
                seconds = elapsed % 60;
                timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (isPaused) {
                    gameTimeElement.textContent = timeString + ' (PAUSA)';
                    gameTimeElement.style.color = '#ffa726';
                } else {
                    gameTimeElement.textContent = timeString;
                    gameTimeElement.style.color = '';
                }
            }
        }
        
        // Funzione separata per sincronizzare lo stato JavaScript con il C++
        function syncGameStateWithCpp() {
            try {
                // Se c'√® un menu mobile attivo o long press in corso, NON sincronizzare
                const mobilePauseMenu = document.getElementById('mobilePauseMenu');
                if ((mobilePauseMenu && mobilePauseMenu.classList.contains('active')) || longPressTriggered || mobilePauseActive) {
                    console.log('üö´ Sync disabilitata - sistema mobile pause attivo');
                    return;
                }
                
                if (typeof Module !== 'undefined' && Module._isGameRunning && Module._isGamePaused) {
                    const cppRunning = Module._isGameRunning();
                    const cppPaused = Module._isGamePaused();
                    
                    // Rileva game over: non running e non paused
                    if (!cppRunning && !cppPaused && !isGameOver && gameStartTimeReal) {
                        console.log('üéÆ GAME OVER detected - syncing state');
                        isGameOver = true;
                        isTimerRunning = false;
                        isPaused = false;
                        if (!gameEndTime) {
                            gameEndTime = Date.now();
                            
                            // Se eravamo in pausa, calcola il tempo di pausa finale
                            if (pauseStartTime) {
                                totalPausedTime += gameEndTime - pauseStartTime;
                                pauseStartTime = null;
                            }
                            
                            console.log('‚è∞ Timer stopped at game over:', new Date(gameEndTime).toLocaleTimeString());
                        }
                    }
                    // Rileva pausa
                    else if (cppPaused && !isPaused && !isGameOver) {
                        console.log('üéÆ PAUSE detected - syncing state');
                        isPaused = true;
                        isTimerRunning = false;
                        if (!pauseStartTime) {
                            pauseStartTime = Date.now();
                        }
                    }
                    // Rileva resume
                    else if (!cppPaused && isPaused && cppRunning) {
                        console.log('üéÆ RESUME detected - syncing state');
                        if (pauseStartTime) {
                            totalPausedTime += Date.now() - pauseStartTime;
                            pauseStartTime = null;
                        }
                        isPaused = false;
                        isTimerRunning = true;
                    }
                    // Rileva RESTART dopo game over: game running ma era game over
                    else if (cppRunning && !cppPaused && isGameOver) {
                        console.log('üéÆ RESTART after game over detected - resetting all info');
                        resetGameInfo(); // Reset completo delle informazioni
                    }
                }
            } catch(e) {
                // Ignora errori di sincronizzazione
            }
        }
        
        // Funzione semplice per aggiornare solo il display dello stato
        function updateGameState() {
            const gameStateElement = document.getElementById('gameState');
            if (!gameStateElement) return;
            
            // Aggiorna solo il display dello stato
            if (isGameOver) {
                gameStateElement.textContent = 'Game Over';
                gameStateElement.style.color = '#ff5722';
                gameStateElement.style.textShadow = '0 0 10px #ff5722';
            } else if (isPaused || !isTimerRunning) {
                gameStateElement.textContent = 'Pausa';
                gameStateElement.style.color = '#ffb74d';
                gameStateElement.style.textShadow = '0 0 8px #ffb74d';
            } else {
                gameStateElement.textContent = 'In corso';
                gameStateElement.style.color = '';
                gameStateElement.style.textShadow = '';
            }
        }
        
        function handleGameOver() {
            console.log('üéÆ GAME OVER DETECTED! Stopping timer.');
            
            // Ferma il timer
            if (!gameEndTime) {
                isTimerRunning = false;
                gameEndTime = Date.now();
                
                // Se eravamo in pausa quando il gioco √® finito, aggiungi l'ultima pausa
                if (pauseStartTime) {
                    const finalPauseDuration = gameEndTime - pauseStartTime;
                    totalPausedTime += finalPauseDuration;
                    pauseStartTime = null;
                }
                
                console.log('‚è∞ Timer stopped at:', new Date(gameEndTime).toLocaleTimeString());
                console.log('üìä Total paused time:', Math.floor(totalPausedTime / 1000), 'seconds');
            }
            
            // La musica √® gestita dal codice C++ del gioco
            
            // Aggiorna il record se necessario
            if (lastScore > highScore) {
                highScore = lastScore;
                localStorage.setItem('tetris-high-score', highScore);
                console.log('üèÜ New high score:', highScore);
                
                // Mostra notifica nuovo record
                const highScoreElement = document.getElementById('highScore');
                if (highScoreElement) {
                    highScoreElement.style.color = '#ff9800';
                    highScoreElement.style.textShadow = '0 0 15px #ff9800';
                    highScoreElement.textContent = parseInt(highScore).toLocaleString();
                }
            }
        }
        
        // Funzione per testare manualmente il game over
        window.triggerGameOver = function() {
            console.log('üß™ Manual game over trigger');
            isGameOver = true;
            handleGameOver();
        };
        
        // Le funzioni audio sono gestite dal codice C++ del gioco
        
        // Funzioni per controllare manualmente il timer
        function pauseTimer() {
            if (isTimerRunning && !isGameOver) {
                isPaused = true;
                pauseStartTime = Date.now();
                console.log('‚è∏Ô∏è Timer paused');
                
                // Aggiorna il display
                const gameStateElement = document.getElementById('gameState');
                if (gameStateElement) {
                    gameStateElement.textContent = 'In pausa';
                    gameStateElement.style.color = '#ffa726';
                }
            }
        }
        
        function resumeTimer() {
            if (isPaused && !isGameOver) {
                if (pauseStartTime) {
                    const pauseDuration = Date.now() - pauseStartTime;
                    totalPausedTime += pauseDuration;
                    console.log('‚ñ∂Ô∏è Timer resumed, pause duration:', Math.floor(pauseDuration / 1000), 'seconds');
                }
                isPaused = false;
                pauseStartTime = null;
                
                // Aggiorna il display
                const gameStateElement = document.getElementById('gameState');
                if (gameStateElement) {
                    gameStateElement.textContent = 'In corso';
                    gameStateElement.style.color = '';
                }
            }
        }
        
        function stopTimer() {
            console.log('üõë Stopping timer (game over)');
            
            isGameOver = true;
            isTimerRunning = false;
            gameEndTime = Date.now();
            
            if (pauseStartTime) {
                pauseStartTime = null;
            }
            
            handleGameOver();
        }
        
        // Funzioni esposte per test manuali
        window.pauseTimer = pauseTimer;
        window.resumeTimer = resumeTimer;
        window.stopTimer = stopTimer;
        window.restartTimer = restartTimer;
        
        // Funzioni FORZATE che funzionano sempre
        function forceCompleteRestart() {
            console.log('ÔøΩ SAFE COMPLETE RESTART - Timer + Game');
            
            // STEP 1: RESETTA TUTTO JavaScript
            gameStartTimeReal = Date.now();
            isTimerRunning = true;
            isGameOver = false;
            isPaused = false;
            totalPausedTime = 0;
            pauseStartTime = null;
            gameEndTime = null;
            lastScore = 0;
            
            // STEP 2: AGGIORNA DISPLAY SUBITO
            const gameTimeElement = document.getElementById('gameTime');
            const gameStateElement = document.getElementById('gameState');
            
            if (gameTimeElement) {
                gameTimeElement.style.color = '';
                gameTimeElement.textContent = '00:00';
            }
            
            if (gameStateElement) {
                gameStateElement.style.color = '';
                gameStateElement.textContent = 'In corso';
            }
            
            // STEP 3: RIAVVIA IL GIOCO C++ IN MODO SICURO
            console.log('üéÆ Trying safe C++ restart...');
            
            try {
                if (typeof Module !== 'undefined') {
                    // Prova prima _restartTetrisGame
                    if (Module._restartTetrisGame) {
                        console.log('Calling _restartTetrisGame...');
                        Module._restartTetrisGame();
                        console.log('‚úÖ _restartTetrisGame called successfully');
                    }
                    // Se non esiste, prova _startTetrisGame
                    else if (Module._startTetrisGame) {
                        console.log('Calling _startTetrisGame...');
                        Module._startTetrisGame();
                        console.log('‚úÖ _startTetrisGame called successfully');
                    }
                    // Ultimo tentativo: usa ccall se disponibile
                    else if (Module.ccall) {
                        try {
                            console.log('Trying ccall method...');
                            Module.ccall('restartTetrisGame', null, []);
                            console.log('‚úÖ ccall restart succeeded');
                        } catch(e) {
                            try {
                                Module.ccall('startTetrisGame', null, []);
                                console.log('‚úÖ ccall start succeeded');
                            } catch(e2) {
                                console.log('‚ùå ccall methods failed');
                            }
                        }
                    }
                    else {
                        console.log('‚ùå No C++ restart methods available');
                        console.log('Available Module functions:');
                        window.listModuleFunctions();
                    }
                } else {
                    console.log('‚ùå Module not available');
                }
            } catch(e) {
                console.error('‚ùå C++ restart failed:', e);
            }
            
            console.log('‚úÖ RESTART COMPLETED - Timer is running, C++ hopefully restarted');
        }
        
        function forcePause() {
            console.log('üí• FORCING PAUSE');
            
            if (!isPaused && !isGameOver) {
                isPaused = true;
                isTimerRunning = false;  // FERMA IL TIMER SUBITO
                pauseStartTime = Date.now();
                
                // AGGIORNA DISPLAY SUBITO
                const gameStateElement = document.getElementById('gameState');
                if (gameStateElement) {
                    gameStateElement.textContent = 'In pausa';
                    gameStateElement.style.color = '#ffa726';
                }
                
                console.log('‚úÖ PAUSE FORCED - Timer stopped');
            }
        }
        
        function forceResume() {
            console.log('üí• FORCING RESUME');
            
            if (isPaused && !isGameOver) {
                if (pauseStartTime) {
                    const pauseDuration = Date.now() - pauseStartTime;
                    totalPausedTime += pauseDuration;
                    console.log('‚è±Ô∏è Added pause duration:', pauseDuration, 'ms');
                }
                
                isPaused = false;
                isTimerRunning = true;  // RIPRENDI IL TIMER SUBITO
                pauseStartTime = null;
                
                // AGGIORNA DISPLAY SUBITO
                const gameStateElement = document.getElementById('gameState');
                if (gameStateElement) {
                    gameStateElement.textContent = 'In corso';
                    gameStateElement.style.color = '';
                }
                
                console.log('‚úÖ RESUME FORCED - Timer running');
            }
        }
        
        // Funzioni aggiuntive per controllo manuale
        window.startGameTimer = function() {
            console.log('üéÆ Starting game timer manually');
            gameStartTimeReal = Date.now();
            isTimerRunning = true;
            isGameOver = false;
            isPaused = false;
            totalPausedTime = 0;
            pauseStartTime = null;
            gameEndTime = null;
            
            const gameStateElement = document.getElementById('gameState');
            if (gameStateElement) {
                gameStateElement.textContent = 'In corso';
                gameStateElement.style.color = '';
            }
        };
        
        window.stopGameTimer = function() {
            console.log('üéÆ Stopping game timer manually');
            isGameOver = true;
            isTimerRunning = false;
            gameEndTime = Date.now();
            
            const gameStateElement = document.getElementById('gameState');
            if (gameStateElement) {
                gameStateElement.textContent = 'Game Over';
                gameStateElement.style.color = '#ff5722';
            }
        };
        
        window.forceCompleteRestart = forceCompleteRestart;
        window.forcePause = forcePause;
        window.forceResume = forceResume;
        
        // Debug function to see available Module functions
        window.listModuleFunctions = function() {
            if (typeof Module !== 'undefined') {
                console.log('Available Module functions:');
                for (let key in Module) {
                    if (typeof Module[key] === 'function' && key.startsWith('_')) {
                        console.log('  ' + key);
                    }
                }
            } else {
                console.log('Module not available yet');
            }
        };
        
        // Debug function to check game state
        window.checkGameState = function() {
            console.log('=== GAME STATE DEBUG ===');
            console.log('JavaScript state:');
            console.log('  isTimerRunning:', isTimerRunning);
            console.log('  isPaused:', isPaused);
            console.log('  isGameOver:', isGameOver);
            console.log('  gameStartTimeReal:', gameStartTimeReal);
            
            if (typeof Module !== 'undefined') {
                console.log('C++ state:');
                try {
                    if (Module._isGameRunning) console.log('  isGameRunning:', Module._isGameRunning());
                    if (Module._isGamePaused) console.log('  isGamePaused:', Module._isGamePaused());
                    if (Module._getScore) console.log('  score:', Module._getScore());
                } catch(e) {
                    console.log('  Error reading C++ state:', e);
                }
            } else {
                console.log('C++ Module not available');
            }
            console.log('========================');
        };
        
        // Event listener per la tastiera
    // Small cooldown to avoid rapid pause toggles (ms)
    const PAUSE_TOGGLE_COOLDOWN_MS = 250;
    let lastPauseToggleMs = 0;

        document.addEventListener('keydown', function(event) {
            console.log('Key pressed:', event.key, event.code, 'isTrusted=', event.isTrusted);

            // Ignore synthetic (programmatically-dispatched) keyboard events so
            // simulateKeyPress() (which dispatches events to the canvas) doesn't
            // bubble up and trigger the JS handlers again, causing double toggles.
            if (!event.isTrusted) {
                console.log('Ignoring synthetic key event:', event.key);
                return;
            }

            // Also ignore events whose target is the canvas element. Simulated
            // key events are dispatched directly to the canvas and should be
            // handled by the C++ engine (via Emscripten). If they bubble up to
            // document we must not handle them again in JS.
            try {
                const canvasEl = (typeof Module !== 'undefined' && Module.canvas) ? Module.canvas : document.getElementById('canvas');
                if (canvasEl && event.target === canvasEl) {
                    console.log('Ignoring key event targeted at canvas:', event.key);
                    return;
                }
            } catch (e) {
                // ignore lookup errors
            }
            
            // INVIO - riavvia tutto FORZATAMENTE
            if (event.key === 'Enter' || event.code === 'Enter') {
                console.log('üîÑ ENTER pressed - FORCING complete restart');
                event.preventDefault();
                
                // FORZA il restart completo
                forceCompleteRestart();
                return;
            }
            
            if (event.key === 'Escape' || event.code === 'Escape') {
                console.log('ESC pressed - checking conditions');
                event.preventDefault();
                
                // Se il menu mobile √® gi√† visibile, questo ESC √® per il C++, non fare altro JavaScript
                const mobilePauseMenu = document.getElementById('mobilePauseMenu');
                if (mobilePauseMenu && mobilePauseMenu.classList.contains('active')) {
                    console.log('üì± Mobile menu visibile - ESC per C++, nessuna azione JS');
                    return;
                }
                
                // Se √® in corso un long press, ignora ESC
                if (longPressTriggered) {
                    console.log('üì± Long press in corso - ignorando ESC');
                    return;
                }
                
                // ESC da tastiera fisica - gestisci normalmente
                if (!isGameOver) {
                    const now = Date.now();
                    if (now - lastPauseToggleMs < PAUSE_TOGGLE_COOLDOWN_MS) {
                        console.log('Ignorato ESC rapido (cooldown)');
                        return;
                    }
                    lastPauseToggleMs = now;

                    if (isPaused) {
                        console.log('FORCING resume da tastiera');
                        forceResume();
                    } else {
                        console.log('FORCING pause da tastiera');
                        forcePause();
                    }
                }
            }
            
            // INVIO per ricominciare
            if (event.key === 'Enter' || event.code === 'Enter') {
                console.log('ENTER key detected');
                
                if (isGameOver) {
                    // Se siamo in game over, riavvia immediatamente
                    console.log('ÔøΩ Restarting game from game over state');
                    restartTimer();
                } else if (lastScore > 0) {
                    // Se abbiamo un punteggio e premiamo INVIO, potrebbe essere per ricominciare
                    console.log('üîç ENTER pressed during game, triggering game over first');
                    stopTimer();
                    
                    // Poi riavvia dopo un breve delay
                    setTimeout(() => {
                        console.log('üîÑ Auto-restarting after ENTER');
                        restartTimer();
                    }, 500);
                } else {
                    // Punteggio 0, probabilmente nuovo gioco
                    console.log('üÜï ENTER pressed with score 0, ensuring timer is active');
                    if (!isTimerRunning) {
                        restartTimer();
                    }
                }
            }
            
            // Per test: Ctrl+G per trigger game over
            if (event.ctrlKey && event.key === 'g') {
                console.log('Manual game over triggered');
                stopTimer();
            }
        });
        
        // Funzione per riavviare il timer per una nuova partita
        function restartTimer() {
            console.log('üîÑ Restarting timer AND game');
            
            // Reset completo
            isGameOver = false;
            isTimerRunning = true;
            isPaused = false;  // Reset anche lo stato pausa
            gameEndTime = null;
            gameStartTimeReal = Date.now();
            totalPausedTime = 0;
            pauseStartTime = null;
            lastScoreChangeTime = Date.now();
            lastScoreCheck = 0;
            scoreStuckCount = 0;
            
            // Reset display
            const gameTimeElement = document.getElementById('gameTime');
            const gameStateElement = document.getElementById('gameState');
            
            if (gameTimeElement) {
                gameTimeElement.style.color = '';
                gameTimeElement.textContent = '00:00';
            }
            
            if (gameStateElement) {
                gameStateElement.style.color = '';
                gameStateElement.style.textShadow = '';
                gameStateElement.textContent = 'In corso';
            }
            
            // Riavvia anche il gioco C++
            try {
                if (typeof Module !== 'undefined') {
                    // Usa la nuova funzione dedicata per il restart
                    if (Module._restartTetrisGame) {
                        console.log('üéÆ Restarting with _restartTetrisGame...');
                        Module._restartTetrisGame();
                    } else if (Module._startTetrisGame) {
                        console.log('üéÆ Restarting with _startTetrisGame...');
                        Module._startTetrisGame();
                    } else {
                        console.log('‚ö†Ô∏è No restart function found. Available functions:');
                        window.listModuleFunctions();
                        console.log('üí° Use window.listModuleFunctions() to see all available functions');
                    }
                } else {
                    console.log('‚ö†Ô∏è Module not available yet');
                }
            } catch(e) {
                console.error('Error restarting C++ game:', e);
            }
            
            console.log('‚úÖ Timer and game restarted');
        }
        
        // Funzioni esposte per test manuali
        window.restartTimer = restartTimer;
        window.forceGameOver = function() {
            console.log('üß™ Forcing game over for testing');
            stopTimer();
        };
        
        window.gameInfo = function() {
            console.log('üéÆ Game State:', {
                isGameOver: isGameOver,
                isTimerRunning: isTimerRunning,
                lastScore: lastScore,
                scoreStuckCount: scoreStuckCount,
                timeElapsed: gameStartTimeReal ? Math.floor((Date.now() - gameStartTimeReal) / 1000) + 's' : 'Not started'
            });
        };
        
        // Aggiungi pulsante di test nella console
        console.log('üéÆ Tetris Timer Controls:');
        console.log('  pauseTimer() - Pausa il timer');
        console.log('  resumeTimer() - Riprende il timer');
        console.log('  forceGameOver() - Forza game over');
        console.log('  restartTimer() - Riavvia per nuovo gioco');
        console.log('\n‚å®Ô∏è Keyboard Controls:');
        console.log('  ESC - Pausa/Riprendi');
        console.log('  ENTER - Riavvia gioco');
        console.log('  Ctrl+G - Forza game over');
        
        function updateStatsFromCanvasOrEvents() {
            // Usa le funzioni C++ esportate per ottenere le statistiche reali
            if (typeof Module !== 'undefined' && Module._getScore && Module._getLevel && Module._getLines) {
                try {
                    updateStatsFromCpp();
                } catch(e) {
                    console.error('Error calling C++ functions:', e);
                    updateStatsFallback();
                }
            } else {
                updateStatsFallback();
            }
        }
        
        function updateStatsFromCpp() {
            try {
                // Debug: verifica se le funzioni esistono
                console.log('Module functions available:', {
                    getScore: typeof Module._getScore,
                    getLevel: typeof Module._getLevel,
                    getLines: typeof Module._getLines,
                    isGameRunning: typeof Module._isGameRunning
                });
                
                // Chiama le funzioni C++ per ottenere i valori reali
                const currentScore = Module._getScore();
                const currentLevel = Module._getLevel();
                const currentLines = Module._getLines();
                const gameRunning = Module._isGameRunning();
                
                console.log('Raw C++ values:', {currentScore, currentLevel, currentLines, gameRunning});
                
                // Aggiorna sempre i valori (rimuovo il controllo gameRunning per debug)
                lastScore = currentScore;
                lastLevel = currentLevel;
                lastLines = currentLines;
                
                // Aggiorna gli elementi HTML
                const scoreDisplay = document.getElementById('scoreDisplay');
                const levelDisplay = document.getElementById('levelDisplay');
                const linesDisplay = document.getElementById('linesDisplay');
                
                console.log('HTML elements found:', {
                    scoreDisplay: !!scoreDisplay,
                    levelDisplay: !!levelDisplay,
                    linesDisplay: !!linesDisplay
                });
                
                if (scoreDisplay) scoreDisplay.textContent = lastScore.toLocaleString();
                if (levelDisplay) levelDisplay.textContent = lastLevel;
                if (linesDisplay) linesDisplay.textContent = lastLines;
                
                // Check if game restarted (score=0, level=1, gameRunning=true)
                if (gameRunning && currentScore === 0 && currentLevel === 1 && isGameOver) {
                    console.log('üîÑ Game restart detected - resetting info panel');
                    resetGameInfo();
                }
                
                // Simple detection: if score goes from >0 to 0, might be game over
                if (lastScore > 0 && currentScore === 0 && !isGameOver) {
                    console.log('üíÄ Possible game over: score reset to 0');
                    // Don't auto-trigger, let user use ENTER to restart
                }
                
                // Aggiorna il record se necessario
                if (lastScore > highScore) {
                    highScore = lastScore;
                    localStorage.setItem('tetris-high-score', highScore);
                    const highScoreElement = document.getElementById('highScore');
                    if (highScoreElement) {
                        highScoreElement.textContent = parseInt(highScore).toLocaleString();
                        // Effetto visivo per nuovo record
                        highScoreElement.style.color = '#ff9800';
                        highScoreElement.style.textShadow = '0 0 15px #ff9800';
                        setTimeout(() => {
                            highScoreElement.style.color = '';
                            highScoreElement.style.textShadow = '';
                        }, 2000);
                    }
                }
                
                console.log('Stats updated from C++:', {score: lastScore, level: lastLevel, lines: lastLines, running: gameRunning});
                
            } catch(e) {
                console.error('Error in updateStatsFromCpp:', e);
                updateStatsFallback();
            }
        }
        
        function updateStatsSimulated() {
            // Fallback per quando Module.HEAP32 non √® disponibile
            console.log('Using simulated stats (Module.HEAP32 not available)');
            
            // Prova comunque a usare le funzioni C++ esportate se disponibili
            if (typeof Module !== 'undefined' && Module._getScore && Module._getLevel && Module._getLines) {
                try {
                    updateStatsFromCpp();
                    return;
                } catch(e) {
                    console.error('Error calling C++ functions in simulation mode:', e);
                }
            }
            
            // Se proprio non funziona nulla, usa il fallback
            updateStatsFallback();
        }
        
        function updateStatsFallback() {
            // Fallback: mantieni i valori precedenti o usa valori di default
            const scoreDisplay = document.getElementById('scoreDisplay');
            const levelDisplay = document.getElementById('levelDisplay');
            const linesDisplay = document.getElementById('linesDisplay');
            
            if (scoreDisplay && !scoreDisplay.textContent) scoreDisplay.textContent = '0';
            if (levelDisplay && !levelDisplay.textContent) levelDisplay.textContent = '1';
            if (linesDisplay && !linesDisplay.textContent) linesDisplay.textContent = '0';
        }
        
        function resetGameInfo() {
            console.log('üîÑ Starting resetGameInfo...');
            
            // Reset game state
            isGameOver = false;
            isPaused = false;
            isTimerRunning = true;
            
            // Reset time tracking
            gameStartTimeReal = Date.now();
            gameEndTime = null;
            totalPausedTime = 0;
            pauseStartTime = null;
            
            console.log('üîÑ Reset timer variables:', {
                gameStartTimeReal: new Date(gameStartTimeReal).toLocaleTimeString(),
                isTimerRunning,
                isPaused,
                isGameOver
            });
            
            // Update game state element
            const gameStateElement = document.getElementById('gameState');
            if (gameStateElement) {
                gameStateElement.textContent = 'In corso';
                gameStateElement.style.color = '';
                console.log('üîÑ Updated game state display to "In corso"');
            }
            
            // Reset time display (remove FINAL)
            const gameTimeElement = document.getElementById('gameTime');
            if (gameTimeElement) {
                gameTimeElement.textContent = '00:00';
                gameTimeElement.style.color = '';
                console.log('üîÑ Reset time display to "00:00"');
            }
            
            console.log('‚úÖ Game info reset complete');
        }
        
        function stopStatsUpdater() {
            if (statsUpdateInterval) {
                clearInterval(statsUpdateInterval);
                statsUpdateInterval = null;
            }
        }
        
        // Marca l'inizio del gioco per le statistiche
        window.gameStartTime = Date.now();
        
        // Responsive layout function
        function fitCanvasToViewport() {
            console.log('Fitting canvas to viewport...');
            
            const gameWrapper = document.querySelector('.game-wrapper');
            const gameLayout = document.querySelector('.game-layout');
            const canvas = document.getElementById('canvas');
            
            if (!gameWrapper || !gameLayout || !canvas) return;
            
            // Calculate available space
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            const isMobile = viewportWidth <= 768;
            
            if (isMobile) {
                // Mobile: smaller canvas to fit stats and info panels
                const reservedHeight = 280; // header + stats + info + footer + padding
                const maxCanvasHeight = Math.min(viewportHeight - reservedHeight, 420);
                const maxCanvasWidth = Math.min(viewportWidth * 0.7, 360); // smaller width
                
                canvas.style.maxWidth = maxCanvasWidth + 'px';
                canvas.style.maxHeight = maxCanvasHeight + 'px';
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
                
                // Ensure canvas is perfectly centered and aligned with stats/info
                canvas.style.display = 'block';
                canvas.style.margin = '0 auto';
                canvas.style.position = 'static';
                canvas.style.left = 'auto';
                canvas.style.transform = 'none';
                
                // Center the game wrapper and ensure consistent alignment
                gameWrapper.style.margin = '0 auto';
                gameWrapper.style.maxWidth = '95vw';
                gameWrapper.style.textAlign = 'center';
                
                // Ensure game canvas container aligns with stats panels
                const gameCanvasContainer = document.querySelector('.game-canvas');
                if (gameCanvasContainer) {
                    gameCanvasContainer.style.justifyContent = 'center';
                    gameCanvasContainer.style.alignItems = 'center';
                    gameCanvasContainer.style.width = '100%';
                    gameCanvasContainer.style.textAlign = 'center';
                }
            } else {
                // Desktop: center layout with stats panels
                canvas.style.maxWidth = '';
                canvas.style.maxHeight = '';
                canvas.style.width = 'auto';
                canvas.style.height = 'auto';
                
                // Center the game wrapper
                gameWrapper.style.margin = '0 auto';
                gameWrapper.style.maxWidth = '1200px';
            }
            
            console.log('Canvas fitted:', { isMobile, viewportWidth, viewportHeight });
        }
        
    /*
     Mobile touch controls and long-press handling

     Changes added: prevent the pause menu from opening on rapid consecutive taps.
     - Implements a true long-press detection (LONG_PRESS_TIME)
     - Suppresses long-press if user performed a burst of quick taps (recentTapCount)
     - Adds a short cooldown after a successful long-press to avoid immediate re-triggering
     These guards prevent accidental pause menu openings on mobile when users tap
     quickly multiple times. Adjust LONG_PRESS_TIME, TAP_BURST_THRESHOLD and
     LONG_PRESS_COOLDOWN to tune behavior.
    */
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let lastTapTime = 0;
        const TAP_DEBOUNCE = 250; // ms
        const TAP_HOLD_TIME = 300; // ms max for a tap
        const LONG_PRESS_TIME = 2000; // ms for long press (2 seconds)
        let longPressTimer = null;
        let longPressTriggered = false;
        let touchMoved = false;
        let mobilePauseActive = false; // Track mobile pause state
        // Anti-accidental-open guards
        let recentTapCount = 0;           // number of quick taps in a short burst
        let tapBurstResetTimer = null;   // timer to reset recentTapCount
        const TAP_BURST_WINDOW = 700;    // ms window to consider taps part of a burst
        const TAP_BURST_THRESHOLD = 3;   // if >=this in window, suppress long-press briefly
        let lastLongPressTime = 0;       // timestamp of last successful long-press
        const LONG_PRESS_COOLDOWN = 1200; // ms cooldown after a long-press
    // Track whether a touch started on the canvas so body fallback ignores it
    let canvasTouchActive = false;
        // Throttle for lateral moves to prevent multiple rapid moves from a single swipe
        let lastLateralMoveTime = 0;
        const MOVE_THROTTLE_MS = 120; // ms between lateral moves

        function attemptLateralMove(direction) {
            const now = Date.now();
            if (now - lastLateralMoveTime < MOVE_THROTTLE_MS) {
                // too soon, ignore
                //console.log('Lateral move throttled');
                return false;
            }
            lastLateralMoveTime = now;
            if (direction === 'left') simulateKeyPress('ArrowLeft');
            else simulateKeyPress('ArrowRight');
            return true;
        }

        function addTouchControls() {
            const canvas = document.getElementById('canvas');
            if (!canvas) return;

            // dynamically compute swipe threshold based on canvas size
            function getMinSwipeDistance() {
                const w = Math.max(200, canvas.clientWidth || window.innerWidth);
                return Math.max(18, Math.min(60, Math.round(w * 0.12))); // 12% of canvas width, clamped
            }

            // Prevent default touch behaviors
            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) return; // ignore multi-touch
                e.preventDefault();
                e.stopPropagation();
                canvasTouchActive = true;
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartTime = Date.now();
                longPressTriggered = false;
                touchMoved = false;
                
                // Start long press timer only if touch stays still
                // Reset any previous long press timer for safety
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                longPressTimer = setTimeout(() => {
                    // Double check: only trigger if no movement occurred, timer wasn't cancelled,
                    // the touch actually lasted LONG_PRESS_TIME, and we're not in a recent tap burst.
                    const now = Date.now();
                    const actualTouchDuration = now - touchStartTime;

                    // Suppress if a long-press was triggered very recently
                    if (now - lastLongPressTime < LONG_PRESS_COOLDOWN) {
                        console.log('üö´ Ignoring long press due to cooldown');
                        return;
                    }

                    // If quick tap burst detected, don't allow accidental long-presses
                    if (recentTapCount >= TAP_BURST_THRESHOLD) {
                        console.log('üö´ Suppressing long press due to recent tap burst:', recentTapCount);
                        return;
                    }

                    // Finally ensure movement didn't occur and duration is sufficient
                    if (!touchMoved && longPressTimer !== null && canvasTouchActive && actualTouchDuration >= LONG_PRESS_TIME) {
                        longPressTriggered = true;
                        lastLongPressTime = now;
                        console.log('‚úÖ Long press activated - conditions met (duration:', actualTouchDuration + 'ms)');
                        showMobilePauseMenu();
                    } else {
                        console.log('‚ùå Long press cancelled - movement detected, too short, or timer cleared', { touchMoved, actualTouchDuration });
                    }
                }, LONG_PRESS_TIME);
            }, { passive: false });

            canvas.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) return; // ignore multi-touch
                e.preventDefault();
                
                const touch = e.touches[0];
                const deltaX = Math.abs(touch.clientX - touchStartX);
                const deltaY = Math.abs(touch.clientY - touchStartY);
                
                // If significant movement, cancel long press (but only if not already triggered)
                if (deltaX > 20 || deltaY > 20) { // Increased threshold to be even less sensitive
                    if (!longPressTriggered && !touchMoved) {
                        touchMoved = true;
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                            console.log('üö´ Long press cancelled due to movement:', { deltaX, deltaY });
                        }
                    }
                }
            }, { passive: false });

            canvas.addEventListener('touchend', function(e) {
                if (e.changedTouches.length > 1) return; // ignore multi-touch
                e.preventDefault();
                e.stopPropagation();

                // If long press was already triggered, don't cancel it
                if (longPressTriggered) {
                    console.log('‚úÖ Long press was triggered, keeping it active');
                    canvasTouchActive = false;
                    touchMoved = false; // Reset for next touch
                    longPressTriggered = false; // Reset for next touch
                    return;
                }

                // Only clear timer if long press wasn't triggered
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    const touchDuration = Date.now() - touchStartTime;
                    console.log('üö´ Long press timer cancelled - touch too short:', touchDuration + 'ms');
                }

                // Compute touch end coordinates first (fix TDZ ReferenceError)
                const touch = e.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;
                const touchEndTime = Date.now();

                // If this was a short tap (not a swipe), account it in recentTapCount so
                // a burst of quick taps doesn't accidentally allow a long-press immediately after.
                if (Math.abs(touchEndX - touchStartX) < 20 && Math.abs(touchEndY - touchStartY) < 20 && (touchEndTime - touchStartTime) < TAP_HOLD_TIME) {
                    recentTapCount++;
                    if (tapBurstResetTimer) clearTimeout(tapBurstResetTimer);
                    tapBurstResetTimer = setTimeout(() => {
                        recentTapCount = 0;
                        tapBurstResetTimer = null;
                    }, TAP_BURST_WINDOW);
                    console.log('üîî Registered quick tap, burst count:', recentTapCount);
                }

                if (!gameStartRequested) {
                    canvasTouchActive = false;
                    touchMoved = false; // Reset for next touch
                    return;
                }

                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const deltaTime = touchEndTime - touchStartTime;

                const minSwipeDistance = getMinSwipeDistance();

                // Short tap -> rotate (debounced)
                if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance && deltaTime < TAP_HOLD_TIME) {
                    const now = Date.now();
                    if (now - lastTapTime > TAP_DEBOUNCE) {
                        lastTapTime = now;
                        simulateKeyPress('ArrowUp');
                        console.log('üîÑ Tap rotate executed');
                    } else {
                        console.log('Tap ignored due to debounce');
                    }
                    canvasTouchActive = false;
                    touchMoved = false; // Reset for next touch
                    return;
                }

                // Horizontal swipe (move left/right)
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0) attemptLateralMove('right'); else attemptLateralMove('left');
                    canvasTouchActive = false;
                    return;
                }

                // Vertical swipe down (fast drop)
                if (deltaY > Math.abs(deltaX) && Math.abs(deltaY) > minSwipeDistance) {
                    simulateKeyPress('ArrowDown');
                    canvasTouchActive = false;
                    return;
                }

                canvasTouchActive = false;
            }, { passive: false });

            // Prevent scrolling and zooming when touching the canvas
            canvas.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) return;
                e.preventDefault();
            }, { passive: false });
        }

        function simulateKeyPress(key) {
            console.log('Simulating key press:', key);

            // Prefer dispatching to the canvas element used by Module
            const targetCanvas = (typeof Module !== 'undefined' && Module.canvas) ? Module.canvas : document.getElementById('canvas');
            if (!targetCanvas) return;

            const keyCode = getKeyCode(key) || 0;

            // Prevent dispatching the same simulated key too frequently
            if (!simulateKeyPress._lastDispatch) simulateKeyPress._lastDispatch = {};
            const last = simulateKeyPress._lastDispatch[key] || 0;
            const now = Date.now();
            const SIMULATE_KEY_COOLDOWN_MS = 120; // small cooldown for simulated keys
            if (now - last < SIMULATE_KEY_COOLDOWN_MS) {
                console.log('Skipping simulated key (cooldown):', key);
                return;
            }
            simulateKeyPress._lastDispatch[key] = now;

            try {
                // Ensure the canvas has focus so SDL receives keyboard events
                if (typeof targetCanvas.focus === 'function') {
                    try { targetCanvas.focus({ preventScroll: true }); } catch(e) { targetCanvas.focus(); }
                }

                // Dispatch keydown
                const keyDownEvent = new KeyboardEvent('keydown', {
                    key: key,
                    code: key,
                    keyCode: keyCode,
                    which: keyCode,
                    bubbles: true,
                    cancelable: true
                });
                targetCanvas.dispatchEvent(keyDownEvent);

                // Also dispatch a keypress event which some engines expect
                const keyPressEvent = new KeyboardEvent('keypress', {
                    key: key,
                    code: key,
                    keyCode: keyCode,
                    which: keyCode,
                    bubbles: true,
                    cancelable: true
                });
                targetCanvas.dispatchEvent(keyPressEvent);

                // Hold key a bit longer to help native SDL handlers capture it
                const KEY_HOLD_MS = 180;
                setTimeout(() => {
                    const keyUpEvent = new KeyboardEvent('keyup', {
                        key: key,
                        code: key,
                        keyCode: keyCode,
                        which: keyCode,
                        bubbles: true,
                        cancelable: true
                    });
                    targetCanvas.dispatchEvent(keyUpEvent);
                }, KEY_HOLD_MS);
            } catch (e) {
                console.error('simulateKeyPress error:', e);
            }
        }
        
        function getKeyCode(key) {
            const codes = {
                'ArrowUp': 38,
                'ArrowDown': 40,
                'ArrowLeft': 37,
                'ArrowRight': 39,
                'Up': 38,
                'Down': 40,
                'Left': 37,
                'Right': 39
            };
            return codes[key] || 0;
        }

        // Initialize touch controls immediatamente e quando il container diventa visibile
        setTimeout(() => {
            console.log('Adding touch controls immediately...');
            addTouchControls();
        }, 1000);
        
        // Fallback: aggiungi controlli touch anche al body per essere sicuri
        function addBodyTouchControls() {
            console.log('Adding fallback touch controls to body');

            // Reuse same helpers as canvas handlers
            function getMinSwipeDistanceForBody() {
                const canvas = document.getElementById('canvas');
                if (canvas) {
                    const w = Math.max(200, canvas.clientWidth || window.innerWidth);
                    return Math.max(18, Math.min(60, Math.round(w * 0.12)));
                }
                return Math.max(18, Math.round(window.innerWidth * 0.12));
            }

            document.body.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) return;
                // If the touch originated on the canvas we should ignore here
                if (canvasTouchActive) return;
                if (gameStartRequested) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    touchStartTime = Date.now();
                }
            }, { passive: false });

            document.body.addEventListener('touchend', function(e) {
                if (e.changedTouches.length > 1) return;
                // Ignore if canvas handled it
                if (canvasTouchActive) return;
                if (!gameStartRequested) return;

                e.stopPropagation();

                const touch = e.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;
                const touchEndTime = Date.now();

                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const deltaTime = touchEndTime - touchStartTime;

                const minSwipeDistance = getMinSwipeDistanceForBody();

                // Tap (rotate) with debounce
                if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance && deltaTime < TAP_HOLD_TIME) {
                    const now = Date.now();
                    if (now - lastTapTime > TAP_DEBOUNCE) {
                        lastTapTime = now;
                        simulateKeyPress('ArrowUp');
                    }
                    return;
                }

                // Horizontal swipe
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0) attemptLateralMove('right'); else attemptLateralMove('left');
                    return;
                }

                // Vertical swipe down
                if (deltaY > Math.abs(deltaX) && Math.abs(deltaY) > minSwipeDistance) {
                    simulateKeyPress('ArrowDown');
                    return;
                }
            }, { passive: false });
        }
        
        // Attiva anche i controlli body
        setTimeout(addBodyTouchControls, 500);
        
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (gameContainer.classList.contains('visible')) {
                        console.log('Game container visible, re-adding touch controls...');
                        setTimeout(addTouchControls, 100);
                        observer.disconnect();
                    }
                }
            });
        });

        observer.observe(gameContainer, { attributes: true });

        // Add resize and orientation change listeners
        window.addEventListener('resize', fitCanvasToViewport);
        window.addEventListener('orientationchange', () => {
            setTimeout(fitCanvasToViewport, 100); // delay for orientation to complete
        });
        
        // Mobile game over detection and overlay
        let mobileGameOverActive = false;
        
        function showMobileGameOver(score) {
            if (window.innerWidth <= 768) { // Only on mobile
                mobileGameOverActive = true;
                const overlay = document.getElementById('mobileGameOverOverlay');
                const scoreElement = document.getElementById('mobileGameOverScore');
                const canvas = document.getElementById('canvas');
                
                if (overlay && scoreElement) {
                    scoreElement.textContent = `Punteggio: ${score.toLocaleString()}`;
                    overlay.style.display = 'flex';
                    overlay.classList.add('active');
                    
                    // Hide canvas to prevent native game over text from showing
                    if (canvas) {
                        canvas.style.opacity = '0.1';
                        canvas.style.pointerEvents = 'none';
                    }
                    
                    // Add tap to restart functionality
                    overlay.onclick = () => {
                        console.log('üéÆ Mobile restart tap detected');
                        hideMobileGameOver();
                        resetGameInfo(); // Force immediate reset
                        simulateKeyPress('Enter');
                    };
                }
            }
        }
        
        function hideMobileGameOver() {
            mobileGameOverActive = false;
            const overlay = document.getElementById('mobileGameOverOverlay');
            const canvas = document.getElementById('canvas');
            
            if (overlay) {
                overlay.style.display = 'none';
                overlay.classList.remove('active');
                overlay.onclick = null;
            }
            
            // Restore canvas visibility
            if (canvas) {
                canvas.style.opacity = '1';
                canvas.style.pointerEvents = 'auto';
            }
            
            // Force stats update after game restart
            console.log('Forcing stats update after game restart');
            setTimeout(() => {
                updateStatsFromCpp();
            }, 100); // Small delay to ensure C++ has updated
        }
        
        // Enhanced game over detection for mobile
        let lastKnownScore = 0;
        let gameOverCheckInterval;
        
        function startGameOverMonitoring() {
            if (gameOverCheckInterval) clearInterval(gameOverCheckInterval);
            
            gameOverCheckInterval = setInterval(() => {
                if (typeof Module !== 'undefined' && Module._getScore && Module._isGameRunning) {
                    try {
                        const currentScore = Module._getScore();
                        const gameRunning = Module._isGameRunning();
                        
                        // Game over detected: not running and we had a score
                        if (!gameRunning && currentScore > 0 && !mobileGameOverActive) {
                            console.log('Mobile game over detected, score:', currentScore);
                            showMobileGameOver(currentScore);
                            lastKnownScore = currentScore;
                        }
                        
                        // Game restarted
                        if (gameRunning && currentScore === 0 && lastKnownScore > 0) {
                            console.log('Game restart detected - forcing stats update');
                            hideMobileGameOver();
                            lastKnownScore = 0;
                            // Force immediate stats update
                            updateStatsFromCpp();
                            
                            // More frequent updates for first few seconds after restart
                            let restartUpdateCount = 0;
                            const restartUpdateInterval = setInterval(() => {
                                updateStatsFromCpp();
                                restartUpdateCount++;
                                if (restartUpdateCount >= 10) { // 10 updates = 1 second
                                    clearInterval(restartUpdateInterval);
                                }
                            }, 100); // Update every 100ms for 1 second
                        }
                    } catch(e) {
                        // Ignore errors accessing Module functions
                    }
                }
            }, 500); // Check every 500ms
        }
        
        // Mobile game control buttons
        document.addEventListener('DOMContentLoaded', () => {
            const pauseBtn = document.getElementById('mobilePauseBtn');
            const restartBtn = document.getElementById('mobileRestartBtn');
            
            if (pauseBtn) {
                pauseBtn.addEventListener('click', () => {
                    console.log('Mobile pause clicked');
                    simulateKeyPress('Escape');
                    
                    // Toggle button text
                    if (pauseBtn.textContent.includes('Pausa')) {
                        pauseBtn.textContent = '‚ñ∂Ô∏è Riprendi';
                    } else {
                        pauseBtn.textContent = '‚è∏Ô∏è Pausa';
                    }
                });
            }
            
            if (restartBtn) {
                restartBtn.addEventListener('click', () => {
                    console.log('Mobile restart clicked');
                    simulateKeyPress('Enter');
                    
                    // Reset pause button text
                    if (pauseBtn) {
                        pauseBtn.textContent = '‚è∏Ô∏è Pausa';
                    }
                });
            }
        });
        
        // Mobile game control buttons
        document.addEventListener('DOMContentLoaded', () => {
            const pauseBtn = document.getElementById('mobilePauseBtn');
            const restartBtn = document.getElementById('mobileRestartBtn');
            
            if (pauseBtn) {
                pauseBtn.addEventListener('click', () => {
                    console.log('Mobile pause clicked');
                    simulateKeyPress('Escape');
                    
                    // Toggle button text
                    if (pauseBtn.textContent.includes('Pausa')) {
                        pauseBtn.textContent = '‚ñ∂Ô∏è Riprendi';
                    } else {
                        pauseBtn.textContent = '‚è∏Ô∏è Pausa';
                    }
                });
            }
            
            if (restartBtn) {
                restartBtn.addEventListener('click', () => {
                    console.log('Mobile restart clicked');
                    simulateKeyPress('Enter');
                    
                    // Reset pause button text
                    if (pauseBtn) {
                        pauseBtn.textContent = '‚è∏Ô∏è Pausa';
                    }
                });
            }
        });
        
        // Mobile game control buttons
        document.addEventListener('DOMContentLoaded', () => {
            const pauseBtn = document.getElementById('mobilePauseBtn');
            const restartBtn = document.getElementById('mobileRestartBtn');
            
            if (pauseBtn) {
                pauseBtn.addEventListener('click', () => {
                    console.log('Mobile pause clicked');
                    simulateKeyPress('Escape');
                    
                    // Toggle button text
                    if (pauseBtn.textContent.includes('Pausa')) {
                        pauseBtn.textContent = '‚ñ∂Ô∏è Riprendi';
                    } else {
                        pauseBtn.textContent = '‚è∏Ô∏è Pausa';
                    }
                });
            }
            
            if (restartBtn) {
                restartBtn.addEventListener('click', () => {
                    console.log('Mobile restart clicked');
                    simulateKeyPress('Enter');
                    
                    // Reset pause button text
                    if (pauseBtn) {
                        pauseBtn.textContent = '‚è∏Ô∏è Pausa';
                    }
                });
            }
            
            // Start game over monitoring for mobile
            setTimeout(() => {
                if (window.innerWidth <= 768) {
                    startGameOverMonitoring();
                }
            }, 2000);
        });
        
        // Precarica il gioco in background (senza avviarlo)
        setTimeout(() => {
            // Il gioco si caricher√† ma non si avvier√† automaticamente
        }, 100);
        
        // Mobile pause menu functions
        function showMobilePauseMenu() {
            console.log('üì± Long press detected - checking if menu already active');
            
            // Check if menu is already active
            const menu = document.getElementById('mobilePauseMenu');
            if (menu && menu.classList.contains('active')) {
                console.log('üì± Menu gi√† attivo - ignorando long press');
                return;
            }
            
            // Show menu first
            if (menu) {
                mobilePauseActive = true; // Set flag to disable sync
                menu.classList.add('active');
                console.log('üì± Pause menu shown with overlay');
            }
            
            // Then pause both JavaScript AND C++ game
            setTimeout(() => {
                if (!isGameOver && !isPaused) {
                    console.log('üì± Pausing JavaScript state first');
                    forcePause();
                    
                    // Now pause C++ game engine (only once!)
                    setTimeout(() => {
                        console.log('üì± Pausing C++ game engine');
                        simulateKeyPress('Escape');
                    }, 50);
                } else {
                    console.log('üì± Game already paused or over, just showing menu');
                }
            }, 100);
        }
        
        function hideMobilePauseMenu() {
            const menu = document.getElementById('mobilePauseMenu');
            if (menu) {
                menu.classList.remove('active');
                console.log('üì± Pause menu hidden');
                
                // Re-enable sync after a short delay
                setTimeout(() => {
                    mobilePauseActive = false;
                    console.log('üì± Mobile pause system deactivated - sync re-enabled');
                }, 500);
            }
        }
        
        // Mobile pause menu event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const resumeBtn = document.getElementById('resumeGameBtn');
            const restartBtn = document.getElementById('restartGameBtn');
            
            if (resumeBtn) {
                resumeBtn.addEventListener('click', () => {
                    console.log('üì± Resume clicked');
                    hideMobilePauseMenu();
                    
                    // Resume both JavaScript AND C++ game
                    setTimeout(() => {
                        if (isPaused) {
                            console.log('üì± Resuming JavaScript state first');
                            forceResume();
                            
                            // Now resume C++ game engine (only once!)
                            setTimeout(() => {
                                console.log('üì± Resuming C++ game engine');
                                simulateKeyPress('Escape');
                            }, 50);
                        }
                    }, 100);
                });
            }
            
            if (restartBtn) {
                restartBtn.addEventListener('click', () => {
                    console.log('üì± Restart clicked');
                    hideMobilePauseMenu();
                    
                    // Wait a moment then restart
                    setTimeout(() => {
                        resetGameInfo();
                        simulateKeyPress('Enter');
                        console.log('üì± Game restarted');
                    }, 100);
                });
            }
            
            // Close menu when clicking outside (but resume game)
            const menu = document.getElementById('mobilePauseMenu');
            if (menu) {
                document.addEventListener('click', (e) => {
                    if (!menu.contains(e.target) && menu.classList.contains('active')) {
                        console.log('üì± Menu closed by clicking outside');
                        hideMobilePauseMenu();
                        
                        // Resume game when closing menu
                        setTimeout(() => {
                            if (typeof Module !== 'undefined' && Module._isGamePaused) {
                                const isPaused = Module._isGamePaused();
                                if (isPaused) {
                                    simulateKeyPress('Escape');
                                    console.log('üì± Game auto-resumed');
                                }
                            }
                        }, 100);
                    }
                });
            }
        });
        
    </script>
    
    <!-- Script del gioco generato da Emscripten -->
    <script async src="tetris.js"></script>
</body>
</html>